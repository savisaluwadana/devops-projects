# ğŸ³ Complete Docker Guide

A comprehensive guide covering Docker from basics to advanced production patterns.

---

## Table of Contents

1. [Docker Fundamentals](#1-docker-fundamentals)
2. [Container Lifecycle](#2-container-lifecycle)
3. [Images & Dockerfiles](#3-images--dockerfiles)
4. [Networking](#4-networking)
5. [Storage & Volumes](#5-storage--volumes)
6. [Docker Compose](#6-docker-compose)
7. [Multi-Stage Builds](#7-multi-stage-builds)
8. [Security Best Practices](#8-security-best-practices)
9. [Performance Optimization](#9-performance-optimization)
10. [Production Patterns](#10-production-patterns)

---

## 1. Docker Fundamentals

### What is Docker?

Docker is an open-source **containerization platform** that enables developers to package applications and their dependencies into lightweight, portable containers. Unlike traditional virtualization, Docker containers share the host operating system's kernel, making them significantly more efficient in terms of resource usage and startup time.

**Key Characteristics:**
- **Lightweight**: Containers share the host OS kernel, eliminating the need for a full guest OS
- **Portable**: "Build once, run anywhere" - containers work consistently across different environments
- **Isolated**: Each container has its own filesystem, network, and process space
- **Ephemeral**: Containers are designed to be temporary and easily replaceable

### Why Docker Matters

Before Docker, developers faced the infamous "it works on my machine" problem. Applications that worked perfectly in development would fail in production due to differences in:
- Operating system versions
- Library dependencies
- Configuration settings
- Environment variables

Docker solves these problems by creating a **consistent runtime environment** that travels with your application. This leads to:

1. **Faster Development Cycles**: Developers can spin up complex environments in seconds
2. **Simplified Deployment**: The same container runs identically in dev, staging, and production
3. **Better Resource Utilization**: Containers use fewer resources than VMs
4. **Microservices Architecture**: Easy to break monoliths into independently deployable services
5. **Scalability**: Quickly scale applications horizontally by running multiple container instances

### Core Concepts

#### Images
A Docker **image** is a read-only template containing instructions for creating a container. Think of it as a snapshot or blueprint of your application at a specific point in time. Images are built in **layers**, where each layer represents a filesystem change (adding files, installing packages, etc.).

- Images are **immutable** - once created, they never change
- Images are identified by a **name:tag** format (e.g., `nginx:1.25-alpine`)
- Images can be stored in **registries** like Docker Hub, GitHub Container Registry, or private registries

#### Containers
A **container** is a running instance of an image. When you start a container, Docker adds a writable layer on top of the image layers where your application can write data. Multiple containers can be created from the same image, each running independently.

- Containers are **isolated** from each other and the host system
- Containers are **ephemeral** by default - data is lost when the container is removed
- Each container gets its own **network interface**, **process tree**, and **filesystem**

#### Volumes
**Volumes** are the preferred way to persist data generated by containers. Unlike the container's writable layer, volumes exist independently of containers and can be shared between multiple containers.

#### Networks
Docker **networks** enable containers to communicate with each other and the outside world. Docker provides several network drivers (bridge, host, overlay) for different use cases.

### Architecture

Docker uses a **client-server architecture**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         Docker Host                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                     Docker Daemon                          â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚ â”‚
â”‚  â”‚  â”‚   Images    â”‚ â”‚ Containers  â”‚ â”‚      Networks       â”‚  â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚ â”‚
â”‚  â”‚  â”‚   Volumes   â”‚ â”‚   Plugins   â”‚ â”‚     BuildKit        â”‚  â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â–²                                  â”‚
â”‚                              â”‚ REST API                         â”‚
â”‚                              â–¼                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                     Docker CLI                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Components:**
- **Docker Client (docker)**: The command-line tool users interact with. It sends commands to the Docker daemon via REST API.
- **Docker Daemon (dockerd)**: The background service that manages images, containers, networks, and volumes. It listens for API requests and handles container lifecycle operations.
- **Docker Registry**: A service for storing and distributing Docker images. Docker Hub is the default public registry.
- **BuildKit**: Docker's modern build engine that provides improved performance, caching, and security features.

### Container vs VM: A Deep Dive

Understanding the difference between containers and virtual machines is crucial:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Virtual Machine    â”‚     â”‚        Container        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”  â”‚     â”‚  â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”  â”‚
â”‚  â”‚App1â”‚ â”‚App2â”‚ â”‚App3â”‚  â”‚     â”‚  â”‚App1â”‚ â”‚App2â”‚ â”‚App3â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”¤ â”œâ”€â”€â”€â”€â”¤ â”œâ”€â”€â”€â”€â”¤  â”‚     â”‚  â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜  â”‚
â”‚  â”‚Binsâ”‚ â”‚Binsâ”‚ â”‚Binsâ”‚  â”‚     â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚Libsâ”‚ â”‚Libsâ”‚ â”‚Libsâ”‚  â”‚     â”‚  â”‚     Docker Engine   â”‚â”‚
â”‚  â”œâ”€â”€â”€â”€â”¤ â”œâ”€â”€â”€â”€â”¤ â”œâ”€â”€â”€â”€â”¤  â”‚     â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚  â”‚ OS â”‚ â”‚ OS â”‚ â”‚ OS â”‚  â”‚     â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜  â”‚     â”‚  â”‚      Host OS        â”‚â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚     â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚  â”‚     Hypervisor      â”‚â”‚     â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚     â”‚  â”‚      Hardware       â”‚â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚     â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚  â”‚      Hardware       â”‚â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       Heavy & Slow                  Light & Fast
```

| Aspect | Virtual Machines | Containers |
|--------|-----------------|------------|
| **Isolation** | Full OS-level isolation | Process-level isolation |
| **Boot Time** | Minutes | Seconds (milliseconds) |
| **Size** | Gigabytes | Megabytes |
| **Resource Usage** | High (full OS overhead) | Low (shared kernel) |
| **Portability** | Limited | Highly portable |
| **Use Case** | Running different OS, legacy apps | Microservices, modern apps |

**When to use VMs:**
- Running applications that require different operating systems
- Applications that need complete kernel isolation for security
- Legacy applications that can't be containerized

**When to use Containers:**
- Microservices architectures
- CI/CD pipelines
- Development environments
- Cloud-native applications

### How Docker Isolation Works

Docker leverages several Linux kernel features to provide container isolation:

1. **Namespaces**: Provide isolated views of system resources
   - `pid` - Process isolation
   - `net` - Network isolation
   - `mnt` - Mount point isolation
   - `uts` - Hostname isolation
   - `ipc` - Inter-process communication isolation
   - `user` - User ID isolation

2. **Control Groups (cgroups)**: Limit and account for resource usage
   - CPU limits
   - Memory limits
   - I/O limits
   - Network bandwidth limits

3. **Union Filesystems**: Enable layered, copy-on-write file systems
   - OverlayFS (default)
   - Efficient storage using image layers

### Installation

```bash
# Ubuntu/Debian
curl -fsSL https://get.docker.com | sh
sudo usermod -aG docker $USER
newgrp docker

# Verify installation
docker --version
docker info
docker run hello-world

# Enable Docker at boot
sudo systemctl enable docker
sudo systemctl start docker
```

---

## 2. Container Lifecycle

### Understanding Container States

A container's lifecycle goes through several well-defined states. Understanding these states is crucial for debugging, orchestration, and designing resilient applications.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   CONTAINER STATE MACHINE                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    docker run    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚    â”‚ Created â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Running â”‚                     â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                     â”‚
â”‚         â–²                             â”‚                          â”‚
â”‚         â”‚ docker create              â”‚ docker pause              â”‚
â”‚         â”‚                             â–¼                          â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚    â”‚  Image  â”‚                  â”‚ Paused  â”‚                     â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                     â”‚
â”‚                                       â”‚ docker unpause           â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    docker start       â–¼                          â”‚
â”‚    â”‚ Stopped â”‚ â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚    â”‚ (Exited)â”‚                  â”‚ Running â”‚                     â”‚
â”‚    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                     â”‚
â”‚         â”‚                             â”‚                          â”‚
â”‚         â”‚ docker rm                   â”‚ docker stop/kill         â”‚
â”‚         â–¼                             â–¼                          â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚    â”‚ Removed â”‚                  â”‚ Stopped â”‚                     â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Container States Explained:**

| State | Description |
|-------|-------------|
| **Created** | Container exists but hasn't started yet. The filesystem is ready, but no process is running. |
| **Running** | Container's main process (PID 1) is actively executing. This is the normal operational state. |
| **Paused** | Container's processes are suspended using cgroups freezer. Memory state is preserved but no CPU time is allocated. |
| **Stopped/Exited** | Main process has terminated. Container still exists with its filesystem intact. Exit code indicates success (0) or failure (non-zero). |
| **Removed** | Container is deleted. Filesystem and metadata are gone (unless volumes were used). |

### The Ephemeral Nature of Containers

Containers are designed to be **ephemeral** â€“ they can be stopped, destroyed, and replaced by a new instance at any time. This design principle has profound implications:

**What This Means in Practice:**
- ğŸ“¦ **Stateless by Default**: Containers should not store important data in their writable layer
- ğŸ”„ **Replaceable**: If a container is unhealthy, destroy it and create a new one
- ğŸš€ **Fast Recovery**: Starting a new container is faster than fixing a broken one
- ğŸ“Š **Scalable**: Run multiple identical containers behind a load balancer

**The "Cattle vs Pets" Philosophy:**

| Traditional Servers (Pets) | Containers (Cattle) |
|---------------------------|---------------------|
| Named individually (db-server-01) | Numbered (container-a1b2c3) |
| Nursed back to health when sick | Replaced when unhealthy |
| Carefully maintained | Recreated from images |
| Downtime for updates | Rolling updates with zero downtime |

### Container Isolation Levels

Each container gets isolated resources:

| Resource | Isolation Mechanism | What It Isolates |
|----------|-------------------|------------------|
| **Process Tree** | PID Namespace | Each container sees itself as PID 1 |
| **Network** | Network Namespace | Own IP address, ports, routing tables |
| **Filesystem** | Mount Namespace | Own root filesystem from image |
| **Users** | User Namespace | UID 0 in container â‰  UID 0 on host |
| **Hostname** | UTS Namespace | Own hostname and domain name |
| **IPC** | IPC Namespace | Own semaphores, message queues |
| **CPU/Memory** | cgroups | Resource limits and accounting |

### Running Containers

The `docker run` command combines multiple operations: pulling an image (if needed), creating a container, and starting it.

```bash
# Basic run
docker run nginx                         # Run nginx (foreground)
docker run -d nginx                      # Run in background (detached)
docker run -d --name webserver nginx     # With custom name
docker run -d -p 8080:80 nginx           # Map port 8080 to container port 80
docker run -it ubuntu bash               # Interactive terminal

# Run options
docker run -d \
  --name myapp \
  --hostname myapp \
  -p 8080:80 \
  -p 8443:443 \
  -v /host/data:/container/data \
  -v named_volume:/data \
  -e "NODE_ENV=production" \
  -e "API_KEY=secret" \
  --env-file .env \
  -w /app \
  --user 1000:1000 \
  --restart unless-stopped \
  --memory="512m" \
  --cpus="1.0" \
  --network mynetwork \
  --health-cmd="curl -f http://localhost/ || exit 1" \
  --health-interval=30s \
  nginx:alpine
```

**Understanding Key Run Options:**

| Option | Purpose | When to Use |
|--------|---------|-------------|
| `-d` (detach) | Run in background | Production servers, long-running services |
| `-it` (interactive tty) | Attach terminal | Debugging, running commands |
| `-p host:container` | Port mapping | Exposing services to host/network |
| `-v` (volume) | Mount storage | Persisting data, sharing files |
| `-e` (env) | Set variables | Configuration, secrets |
| `--restart` | Auto-restart policy | Production reliability |
| `--memory/--cpus` | Resource limits | Preventing resource exhaustion |
| `--network` | Network attachment | Multi-container communication |

### Container Management

```bash
# List containers
docker ps                    # Running containers
docker ps -a                 # All containers (including stopped)
docker ps -q                 # Only container IDs
docker ps -s                 # With size

# Container information
docker inspect container_name
docker logs container_name
docker logs -f container_name        # Follow logs
docker logs --tail 100 container_name
docker logs --since="2023-01-01" container_name

# Container status
docker stats                 # Live resource usage
docker top container_name    # Running processes

# Execute commands
docker exec container_name command
docker exec -it container_name bash
docker exec -u root container_name command

# Container lifecycle
docker start container_name
docker stop container_name
docker restart container_name
docker pause container_name
docker unpause container_name
docker kill container_name

# Remove containers
docker rm container_name
docker rm -f container_name          # Force remove running container
docker rm $(docker ps -aq)           # Remove all stopped containers
docker container prune               # Remove all stopped containers
```

### Copy Files

```bash
# Copy from host to container
docker cp file.txt container_name:/path/to/dest/

# Copy from container to host
docker cp container_name:/path/to/file.txt ./local/

# Copy entire directories
docker cp container_name:/var/log/ ./logs/
```

---

## 3. Images & Dockerfiles

### Understanding Docker Images

A Docker image is much more than just a file â€“ it's a **layered, immutable snapshot** of a filesystem along with metadata describing how to run it. Understanding image architecture is fundamental to efficient Docker usage.

**Image Layers Explained:**

Every Docker image consists of multiple read-only layers stacked on top of each other. Each layer represents a filesystem change from a Dockerfile instruction.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    IMAGE LAYER ARCHITECTURE                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚    Container (running)                                          â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚    â”‚  Writable Layer (Container Layer)                      â”‚   â”‚
â”‚    â”‚  - All container writes go here                        â”‚   â”‚
â”‚    â”‚  - Deleted when container is removed                   â”‚   â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                           â–²                                     â”‚
â”‚    Image (read-only)      â”‚                                     â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚    â”‚  Layer 4: CMD ["nginx", "-g", "daemon off;"]          â”‚   â”‚
â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚    â”‚  Layer 3: COPY ./app /usr/share/nginx/html            â”‚   â”‚
â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚    â”‚  Layer 2: RUN apt-get install nginx                   â”‚   â”‚
â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚    â”‚  Layer 1: FROM ubuntu:22.04 (base image)              â”‚   â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Why Layers Matter:**

| Benefit | Explanation |
|---------|-------------|
| **Sharing** | Multiple images can share the same base layers, saving disk space |
| **Caching** | Docker caches layers, so rebuilds only recreate changed layers |
| **Distribution** | Only new/changed layers need to be transferred when pulling |
| **Immutability** | Layers never change after creation, ensuring consistency |

### Image Tags and Naming

Docker images use a naming convention that identifies where images come from and which version to use:

```
[registry/][repository/]name[:tag][@digest]
```

**Examples Explained:**

| Full Name | Registry | Repository | Image | Tag |
|-----------|----------|------------|-------|-----|
| `nginx` | Docker Hub (default) | library (official) | nginx | latest (default) |
| `nginx:1.25-alpine` | Docker Hub | library | nginx | 1.25-alpine |
| `myuser/myapp:v1.0` | Docker Hub | myuser | myapp | v1.0 |
| `gcr.io/project/app:latest` | gcr.io | project | app | latest |
| `localhost:5000/myimage` | localhost:5000 | - | myimage | latest |

**Tag Best Practices:**
- âŒ **Avoid `latest`** in production â€“ it's unpredictable
- âœ… Use **semantic versioning** (`v1.2.3`) for releases
- âœ… Use **Git SHA** for CI/CD builds for traceability
- âœ… Use **date-based** tags for nightly builds

### Image Registries

A registry is a storage and distribution system for Docker images. Understanding registries is essential for sharing and deploying containers.

| Registry | URL | Use Case |
|----------|-----|----------|
| **Docker Hub** | hub.docker.com | Default public registry, official images |
| **GitHub Container Registry** | ghcr.io | GitHub integration, private repos |
| **Amazon ECR** | *.dkr.ecr.*.amazonaws.com | AWS-native, integrated with ECS/EKS |
| **Google Container Registry** | gcr.io | GCP-native, integrated with GKE |
| **Azure Container Registry** | *.azurecr.io | Azure-native, integrated with AKS |
| **Harbor** | self-hosted | Open-source, enterprise features |

### Image Management

```bash
# Pull images
docker pull nginx                    # Latest tag
docker pull nginx:1.25               # Specific version
docker pull nginx:alpine             # Alpine variant
docker pull gcr.io/google-containers/nginx  # From other registry

# List images
docker images
docker images -a                     # Include intermediate images
docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"

# Image information
docker inspect nginx
docker history nginx                 # Show layers

# Remove images
docker rmi nginx
docker rmi -f nginx                  # Force remove
docker rmi $(docker images -q)       # Remove all images
docker image prune                   # Remove unused images
docker image prune -a                # Remove all unused images

# Tag and push
docker tag myapp:latest myregistry/myapp:v1.0
docker push myregistry/myapp:v1.0

# Save and load
docker save -o myimage.tar myimage:latest
docker load -i myimage.tar

# Export and import (container filesystem)
docker export container_name > container.tar
docker import container.tar newimage:tag
```

### Dockerfile Syntax

```dockerfile
# ============================================
# Complete Dockerfile Reference
# ============================================

# Base image (required first instruction)
FROM ubuntu:22.04
FROM python:3.11-slim AS builder
FROM scratch                          # Empty base image

# Metadata
LABEL maintainer="you@example.com"
LABEL version="1.0"
LABEL description="My application"

# Arguments (build-time variables)
ARG VERSION=1.0
ARG BUILD_DATE

# Environment variables
ENV NODE_ENV=production
ENV APP_HOME=/app
ENV PATH="$APP_HOME/bin:$PATH"

# Working directory
WORKDIR /app

# Copy files
COPY . .                              # Copy all
COPY package*.json ./                 # Copy specific files
COPY --chown=user:group src/ ./src/   # With ownership
COPY --from=builder /app/dist ./dist  # Multi-stage copy

# Add files (can extract tar and download URLs)
ADD archive.tar.gz /opt/
ADD https://example.com/file.tar.gz /opt/

# Run commands
RUN apt-get update && apt-get install -y \
    package1 \
    package2 \
    && rm -rf /var/lib/apt/lists/*

# Create user
RUN groupadd -r appgroup && useradd -r -g appgroup appuser

# Switch user
USER appuser

# Expose ports (documentation)
EXPOSE 80
EXPOSE 443

# Volumes
VOLUME /data
VOLUME ["/var/log", "/var/data"]

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost/ || exit 1

# Default command
CMD ["nginx", "-g", "daemon off;"]

# Entrypoint (not overridden by docker run arguments)
ENTRYPOINT ["python", "app.py"]
ENTRYPOINT ["/docker-entrypoint.sh"]

# Combine ENTRYPOINT and CMD
ENTRYPOINT ["python", "app.py"]
CMD ["--help"]                        # Default args, can be overridden

# Stop signal
STOPSIGNAL SIGTERM

# Shell form vs exec form
RUN apt-get update               # Shell form (runs in /bin/sh -c)
RUN ["apt-get", "update"]        # Exec form (no shell)
```

### Complete Dockerfile Examples

**Python Application:**
```dockerfile
FROM python:3.11-slim

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PIP_NO_CACHE_DIR=1 \
    PIP_DISABLE_PIP_VERSION_CHECK=1

WORKDIR /app

# Install dependencies first (for caching)
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application
COPY . .

# Create non-root user
RUN groupadd -r appgroup && useradd -r -g appgroup appuser \
    && chown -R appuser:appgroup /app
USER appuser

EXPOSE 8000

HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD python -c "import urllib.request; urllib.request.urlopen('http://localhost:8000/health')" || exit 1

CMD ["gunicorn", "--bind", "0.0.0.0:8000", "app:create_app()"]
```

**Node.js Application:**
```dockerfile
FROM node:18-alpine

WORKDIR /app

# Install dependencies
COPY package*.json ./
RUN npm ci --only=production

# Copy application
COPY . .

# Create non-root user
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nextjs -u 1001 -G nodejs
USER nextjs

EXPOSE 3000

HEALTHCHECK --interval=30s --timeout=3s \
    CMD wget --no-verbose --tries=1 --spider http://localhost:3000/health || exit 1

CMD ["node", "server.js"]
```

**Go Application:**
```dockerfile
# Build stage
FROM golang:1.21-alpine AS builder

WORKDIR /app

# Download dependencies
COPY go.mod go.sum ./
RUN go mod download

# Build
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -ldflags="-w -s" -o /app/main

# Runtime stage
FROM scratch

COPY --from=builder /app/main /main
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/

EXPOSE 8080

ENTRYPOINT ["/main"]
```

### Build Commands

```bash
# Basic build
docker build -t myapp .
docker build -t myapp:v1.0 .
docker build -f Dockerfile.prod -t myapp .

# Build with arguments
docker build --build-arg VERSION=1.0 -t myapp .

# Build with no cache
docker build --no-cache -t myapp .

# Build with target (multi-stage)
docker build --target builder -t myapp:build .

# Build with platform
docker build --platform linux/amd64 -t myapp .

# BuildKit (faster, better caching)
DOCKER_BUILDKIT=1 docker build -t myapp .
```

---

## 4. Networking

### Understanding Container Networking

Docker networking allows containers to communicate with each other and the outside world. Understanding the networking model is crucial for designing microservices architectures.

**The Container Network Model (CNM):**

Docker implements its own networking model called the Container Network Model (CNM), which consists of three building blocks:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  CONTAINER NETWORK MODEL (CNM)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   SANDBOX (Network Namespace)                             â”‚  â”‚
â”‚  â”‚   - Isolated network stack                                â”‚  â”‚
â”‚  â”‚   - Contains interfaces, routes, DNS                      â”‚  â”‚
â”‚  â”‚   - Each container has its own sandbox                    â”‚  â”‚
â”‚  â”‚                                                           â”‚  â”‚
â”‚  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
â”‚  â”‚   â”‚  ENDPOINTS                                       â”‚   â”‚  â”‚
â”‚  â”‚   â”‚  - Virtual network interfaces (veth pairs)       â”‚   â”‚  â”‚
â”‚  â”‚   â”‚  - One end in container, one in Docker network   â”‚   â”‚  â”‚
â”‚  â”‚   â”‚  - Containers can have multiple endpoints        â”‚   â”‚  â”‚
â”‚  â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                              â”‚                                   â”‚
â”‚                              â–¼                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   NETWORK                                                 â”‚  â”‚
â”‚  â”‚   - Group of endpoints that can communicate               â”‚  â”‚
â”‚  â”‚   - Implemented by network drivers                        â”‚  â”‚
â”‚  â”‚   - Provides DNS resolution between containers            â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Network Drivers Explained

Docker provides several network drivers for different use cases:

| Driver | Description | Use Cases |
|--------|-------------|-----------|
| **bridge** | Default. Creates a private internal network on the host. Containers connect via virtual bridge (docker0). | Single-host development, isolated applications |
| **host** | Removes network isolation. Container uses host's network directly. Better performance but no isolation. | Performance-critical applications, debugging |
| **none** | Completely disables networking. Container has only loopback interface. | Maximum security, offline processing |
| **overlay** | Enables multi-host networking. Creates distributed network across Docker swarm nodes. | Docker Swarm, multi-node clusters |
| **macvlan** | Assigns a MAC address to container, making it appear as physical device on network. | Legacy applications requiring direct network access |
| **ipvlan** | Similar to macvlan but shares MAC address. Useful when MAC limits exist. | Environments with MAC address restrictions |

### How Container-to-Container Communication Works

**On the Same Network:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    BRIDGE NETWORK                                â”‚
â”‚                                                                  â”‚
â”‚    Container A                        Container B               â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚    â”‚  eth0        â”‚                  â”‚  eth0        â”‚          â”‚
â”‚    â”‚  172.17.0.2  â”‚                  â”‚  172.17.0.3  â”‚          â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚           â”‚ veth                            â”‚ veth              â”‚
â”‚           â”‚                                 â”‚                   â”‚
â”‚    â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•â•       â”‚
â”‚                     Docker Bridge (docker0)                     â”‚
â”‚                        172.17.0.1                               â”‚
â”‚    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•     â”‚
â”‚                              â”‚                                   â”‚
â”‚                         NAT/iptables                            â”‚
â”‚                              â”‚                                   â”‚
â”‚    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•     â”‚
â”‚                     Host Network Interface                      â”‚
â”‚                              â”‚                                   â”‚
â”‚                          Internet                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**DNS Resolution:**
Containers on user-defined networks can resolve each other by **container name** or **network alias**. This is called **service discovery**.

```bash
# Container "web" can reach container "db" by name
docker exec web ping db  # Works because of built-in DNS
```

### Port Mapping Deep Dive

Port mapping allows external access to container services:

```
Host Port       â†’ Container Port
-p 8080:80      â†’ Request to host:8080 forwarded to container:80
-p 127.0.0.1:8080:80  â†’ Only localhost can access
-p 8080-8090:80-90    â†’ Port range mapping
-P                     â†’ Publish all EXPOSE ports to random host ports
```

**How It Works Internally:**

1. Docker creates iptables rules to forward traffic
2. Traffic to host port is DNATed to container's IP:port
3. Response traffic is SNATed back to the client

### Network Types

```bash
# List networks
docker network ls

# Network types:
# - bridge:  Default network, containers can communicate
# - host:    Use host's network directly
# - none:    No networking
# - overlay: Multi-host networking (Swarm)
# - macvlan: Assign MAC address to container

# Create network
docker network create mynetwork
docker network create --driver bridge mybridge
docker network create --subnet=172.20.0.0/16 mynetwork

# Inspect network
docker network inspect bridge

# Connect/disconnect containers
docker network connect mynetwork container_name
docker network disconnect mynetwork container_name

# Run with network
docker run -d --network mynetwork --name app nginx
docker run -d --network host nginx
docker run -d --network none nginx

# Remove network
docker network rm mynetwork
docker network prune        # Remove unused networks
```

### Container Communication

```bash
# Containers on same custom network can communicate by name
docker network create app-network

docker run -d --name db --network app-network postgres
docker run -d --name api --network app-network \
  -e DATABASE_HOST=db \      # Use container name
  myapi

# Link (legacy, use networks instead)
docker run -d --name db postgres
docker run -d --link db:database myapp

# Port publishing
docker run -d -p 8080:80 nginx                    # Specific port
docker run -d -p 80 nginx                         # Random host port
docker run -d -p 127.0.0.1:8080:80 nginx          # Bind to localhost only
docker run -d -p 8080-8090:80-90 nginx            # Port range
docker run -d -P nginx                            # Publish all exposed ports
```

### DNS and Service Discovery

```bash
# Built-in DNS for custom networks
# Containers can resolve each other by name

# Example
docker network create mynet
docker run -d --name web --network mynet nginx
docker run -it --network mynet alpine ping web   # Works!

# Custom DNS
docker run --dns 8.8.8.8 nginx
docker run --dns-search example.com nginx

# Add host entry
docker run --add-host host.docker.internal:host-gateway nginx
```

---

## 5. Storage & Volumes

### The Data Persistence Challenge

By default, all files created inside a container are stored in a **writable container layer**. This creates several problems:

**Why Container Storage is Problematic:**

| Problem | Explanation |
|---------|-------------|
| **Data Loss** | When a container is removed, its writable layer is deleted. All data is gone forever. |
| **Not Shareable** | Data in one container cannot easily be accessed by another container. |
| **Coupled to Host** | The container's storage driver is tied to the host machine. |
| **Performance** | Union filesystems add overhead compared to direct filesystem access. |

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                THE DATA PERSISTENCE PROBLEM                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  WITHOUT VOLUMES:                                                â”‚
â”‚                                                                  â”‚
â”‚    Container A                      Container A (new)           â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    docker rm    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚    â”‚ App Data    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶  â”‚ Empty!      â”‚              â”‚
â”‚    â”‚ DB Files    â”‚    + run        â”‚ No data!    â”‚              â”‚
â”‚    â”‚ Uploads     â”‚                 â”‚             â”‚              â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚         âŒ All data lost!                                        â”‚
â”‚                                                                  â”‚
â”‚  WITH VOLUMES:                                                   â”‚
â”‚                                                                  â”‚
â”‚    Container A                      Container B (new)           â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    docker rm    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚    â”‚ App         â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶  â”‚ App         â”‚              â”‚
â”‚    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    + run        â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚          â”‚ mount                         â”‚ mount                 â”‚
â”‚          â–¼                               â–¼                       â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚    â”‚            VOLUME (persistent)               â”‚              â”‚
â”‚    â”‚  DB Files, Uploads, Config files            â”‚              â”‚
â”‚    â”‚           (survives container removal)      â”‚              â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚         âœ… Data persists!                                        â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Storage Options Compared

Docker provides three ways to store data:

| Type | Location | Managed By | Persistence | Use Case |
|------|----------|------------|-------------|----------|
| **Volumes** | `/var/lib/docker/volumes/` | Docker | Yes | Production data, databases |
| **Bind Mounts** | Anywhere on host | You | Yes | Development, config files |
| **tmpfs** | Host memory (RAM) | Docker | No (until restart) | Secrets, temporary cache |

**When to Use Each:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                CHOOSING STORAGE TYPE                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  VOLUMES (Recommended for most cases)                           â”‚
â”‚  âœ… Best for: Databases, application data, shared data          â”‚
â”‚  âœ… Docker manages them (easy backup, migration)                â”‚
â”‚  âœ… Work on Linux and Windows containers                        â”‚
â”‚  âœ… Can be shared among multiple containers                     â”‚
â”‚  âœ… Volume drivers allow remote/cloud storage                   â”‚
â”‚                                                                  â”‚
â”‚  BIND MOUNTS                                                     â”‚
â”‚  âœ… Best for: Dev environments, config files, source code       â”‚
â”‚  âš ï¸  Depends on host filesystem structure                       â”‚
â”‚  âš ï¸  Security risk (container can access host files)            â”‚
â”‚  âœ… Changes reflect immediately (great for development)         â”‚
â”‚                                                                  â”‚
â”‚  TMPFS                                                           â”‚
â”‚  âœ… Best for: Secrets, sensitive data, temporary cache          â”‚
â”‚  âœ… Never written to disk (security)                            â”‚
â”‚  âŒ Lost when container stops                                    â”‚
â”‚  âŒ Cannot be shared between containers                         â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Volume Types

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Storage Options                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  1. Volumes (Managed by Docker)                                  â”‚
â”‚     docker volume create mydata                                  â”‚
â”‚     docker run -v mydata:/data nginx                            â”‚
â”‚                                                                  â”‚
â”‚  2. Bind Mounts (Host path)                                      â”‚
â”‚     docker run -v /host/path:/container/path nginx              â”‚
â”‚                                                                  â”‚
â”‚  3. tmpfs (Memory)                                               â”‚
â”‚     docker run --tmpfs /app/temp nginx                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Volume Management

```bash
# Create volume
docker volume create mydata
docker volume create --driver local mydata

# List volumes
docker volume ls

# Inspect volume
docker volume inspect mydata

# Remove volumes
docker volume rm mydata
docker volume prune                   # Remove unused volumes

# Use volume
docker run -v mydata:/data nginx
docker run --mount source=mydata,target=/data nginx

# Anonymous volume
docker run -v /data nginx             # Docker creates volume

# Read-only volume
docker run -v mydata:/data:ro nginx
```

### Bind Mounts

```bash
# Bind mount (absolute path)
docker run -v /host/path:/container/path nginx

# Bind mount (current directory)
docker run -v $(pwd):/app nginx

# Bind mount (read-only)
docker run -v /host/path:/container/path:ro nginx

# Using --mount (more explicit)
docker run --mount type=bind,source=/host/path,target=/container/path nginx

# Bind mount specific file
docker run -v /host/config.yaml:/app/config.yaml:ro nginx
```

### tmpfs Mounts

```bash
# tmpfs mount (memory only, not persisted)
docker run --tmpfs /app/temp nginx

docker run --mount type=tmpfs,destination=/app/temp,tmpfs-size=100m nginx
```

---

## 6. Docker Compose

### Understanding Docker Compose

Docker Compose is a tool for defining and running **multi-container Docker applications**. Instead of running each container separately with long `docker run` commands, you define your entire application stack in a single file.

**Why Docker Compose?**

| Challenge Without Compose | Solution With Compose |
|---------------------------|----------------------|
| Long `docker run` commands with many flags | All configuration in one YAML file |
| Manual container start order | Automatic dependency management |
| Hard to share development environments | `docker-compose.yml` is version controlled |
| Manual network creation and linking | Networks created automatically |
| Inconsistent local vs team environments | Everyone uses same configuration |

**How Docker Compose Works:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 DOCKER COMPOSE ARCHITECTURE                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   docker-compose.yml                                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚ version: '3.8'                                          â”‚   â”‚
â”‚   â”‚ services:                                               â”‚   â”‚
â”‚   â”‚   web:        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶  Container: myapp_web_1       â”‚   â”‚
â”‚   â”‚   api:        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶  Container: myapp_api_1       â”‚   â”‚
â”‚   â”‚   db:         â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶  Container: myapp_db_1        â”‚   â”‚
â”‚   â”‚   redis:      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶  Container: myapp_redis_1     â”‚   â”‚
â”‚   â”‚ networks:                                               â”‚   â”‚
â”‚   â”‚   frontend:   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶  Network: myapp_frontend      â”‚   â”‚
â”‚   â”‚   backend:    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶  Network: myapp_backend       â”‚   â”‚
â”‚   â”‚ volumes:                                                â”‚   â”‚
â”‚   â”‚   db_data:    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶  Volume: myapp_db_data        â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                  â”‚
â”‚   $ docker-compose up                                            â”‚
â”‚                       â”‚                                          â”‚
â”‚                       â–¼                                          â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚               RUNNING APPLICATION                        â”‚   â”‚
â”‚   â”‚                                                          â”‚   â”‚
â”‚   â”‚    â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”            â”‚   â”‚
â”‚   â”‚    â”‚ web â”‚â”€â”€â”€â–¶â”‚ api â”‚â”€â”€â”€â–¶â”‚ db  â”‚    â”‚redisâ”‚            â”‚   â”‚
â”‚   â”‚    â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜            â”‚   â”‚
â”‚   â”‚        â”‚                     â”‚                          â”‚   â”‚
â”‚   â”‚        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚   â”‚
â”‚   â”‚               shared volume                             â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Key Compose Concepts:**

| Concept | Description |
|---------|-------------|
| **Project** | A group of containers defined in one compose file. Named after directory by default. |
| **Service** | A container configuration that can be scaled to multiple instances. |
| **Network** | Virtual network for service communication. Created per project by default. |
| **Volume** | Persistent storage that survives container restarts. |
| **Profile** | Groups services that should only start in certain scenarios (e.g., debugging tools). |

**Compose vs Kubernetes:**

| Aspect | Docker Compose | Kubernetes |
|--------|----------------|------------|
| **Scope** | Single host | Multi-host cluster |
| **Complexity** | Simple, easy to learn | Complex, steep learning curve |
| **Scaling** | Manual or basic (`--scale`) | Auto-scaling, self-healing |
| **Use Case** | Development, simple deployments | Production, large-scale systems |
| **State** | Stateful by default | Prefers stateless, manages state specially |

### Compose File Reference

```yaml
# docker-compose.yml
version: '3.8'

services:
  # Frontend service
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      args:
        NODE_ENV: production
      target: production
    image: myapp/frontend:${TAG:-latest}
    container_name: frontend
    hostname: frontend
    ports:
      - "3000:3000"
      - "3001:3001"
    volumes:
      - ./frontend/src:/app/src:ro
      - frontend_node_modules:/app/node_modules
    environment:
      - NODE_ENV=production
      - API_URL=http://api:8000
    env_file:
      - .env
      - .env.production
    depends_on:
      api:
        condition: service_healthy
    networks:
      - frontend-network
      - backend-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 256M
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  # API service
  api:
    build:
      context: ./api
      dockerfile: Dockerfile.prod
    ports:
      - "8000:8000"
    volumes:
      - ./api:/app
      - /app/node_modules
    environment:
      DATABASE_URL: postgres://user:password@db:5432/myapp
      REDIS_URL: redis://cache:6379
      SECRET_KEY: ${SECRET_KEY}
    depends_on:
      db:
        condition: service_healthy
      cache:
        condition: service_started
    networks:
      - backend-network
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:8000/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  # Database service
  db:
    image: postgres:15-alpine
    container_name: postgres
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: myapp
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U user -d myapp"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - backend-network
    restart: unless-stopped

  # Cache service
  cache:
    image: redis:7-alpine
    command: redis-server --appendonly yes
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - backend-network
    restart: unless-stopped

  # Nginx reverse proxy
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
    depends_on:
      - frontend
      - api
    networks:
      - frontend-network
      - backend-network
    restart: unless-stopped

  # Worker service
  worker:
    build: ./worker
    command: celery -A tasks worker --loglevel=info
    volumes:
      - ./worker:/app
    environment:
      - REDIS_URL=redis://cache:6379
    depends_on:
      - cache
    networks:
      - backend-network
    restart: unless-stopped
    deploy:
      replicas: 2

# Volumes
volumes:
  postgres_data:
    driver: local
  redis_data:
  frontend_node_modules:

# Networks
networks:
  frontend-network:
    driver: bridge
  backend-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.28.0.0/16
```

### Compose Commands

```bash
# Start services
docker compose up
docker compose up -d                   # Detached mode
docker compose up --build              # Rebuild images
docker compose up service1 service2    # Specific services
docker compose up --scale worker=3     # Scale service

# Stop services
docker compose down
docker compose down -v                 # Remove volumes
docker compose down --rmi all          # Remove images
docker compose stop                    # Stop without removing

# View status
docker compose ps
docker compose ps -a
docker compose top

# Logs
docker compose logs
docker compose logs -f                 # Follow
docker compose logs service_name
docker compose logs --tail 100

# Execute commands
docker compose exec service_name command
docker compose exec db psql -U user -d myapp

# Build
docker compose build
docker compose build --no-cache
docker compose build service_name

# Other commands
docker compose pull                    # Pull latest images
docker compose restart                 # Restart services
docker compose config                  # Validate and view config
docker compose config --services       # List services
docker compose images                  # List images
docker compose port service 80         # Show port mapping
```

### Environment Files

```bash
# .env file (automatically loaded)
TAG=v1.0
SECRET_KEY=mysecretkey
DATABASE_PASSWORD=password

# Multiple env files
docker compose --env-file .env.production up

# In compose file
services:
  app:
    env_file:
      - .env
      - .env.local
```

---

## 7. Multi-Stage Builds

### Pattern: Build and Runtime Separation

```dockerfile
# Stage 1: Build
FROM node:18-alpine AS builder

WORKDIR /app

# Install dependencies
COPY package*.json ./
RUN npm ci

# Build application
COPY . .
RUN npm run build

# Stage 2: Runtime
FROM node:18-alpine AS runtime

WORKDIR /app

# Copy only production dependencies
COPY package*.json ./
RUN npm ci --only=production

# Copy built application from builder
COPY --from=builder /app/dist ./dist

# Non-root user
USER node

EXPOSE 3000
CMD ["node", "dist/server.js"]
```

### Pattern: Multi-Environment Builds

```dockerfile
# Base stage
FROM python:3.11-slim AS base
WORKDIR /app
COPY requirements.txt .

# Development stage
FROM base AS development
RUN pip install -r requirements.txt
RUN pip install pytest pytest-cov black flake8
COPY . .
CMD ["python", "-m", "flask", "run", "--host=0.0.0.0", "--debug"]

# Test stage
FROM development AS test
RUN pytest tests/

# Production stage
FROM base AS production
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
RUN useradd -r appuser && chown -R appuser /app
USER appuser
CMD ["gunicorn", "-b", "0.0.0.0:8000", "app:app"]
```

### Build Specific Targets

```bash
# Build development image
docker build --target development -t myapp:dev .

# Build production image
docker build --target production -t myapp:prod .

# Build test image and run tests
docker build --target test -t myapp:test .
```

---

## 8. Security Best Practices

### Dockerfile Security

```dockerfile
# 1. Use specific base image versions
FROM python:3.11.4-slim-bookworm    # Not python:latest

# 2. Create and use non-root user
RUN groupadd -r appgroup && useradd -r -g appgroup appuser
USER appuser

# 3. Use COPY instead of ADD (unless extracting tar)
COPY requirements.txt .              # Preferred
#ADD requirements.txt .              # Avoid

# 4. Don't store secrets in images
# Use secrets at runtime, not build time
# Bad: ENV API_KEY=secret
# Good: Pass at runtime with -e or secrets

# 5. Use multi-stage builds to exclude build tools
FROM node:18 AS builder
# ... build steps
FROM node:18-slim
COPY --from=builder /app/dist ./dist

# 6. Scan for vulnerabilities
# docker scan myimage

# 7. Set read-only filesystem where possible
# docker run --read-only myimage

# 8. Drop capabilities
# docker run --cap-drop=ALL --cap-add=NET_BIND_SERVICE myimage

# 9. Use .dockerignore
# Create .dockerignore file
```

### .dockerignore Example

```dockerignore
# Git
.git
.gitignore

# Docker
Dockerfile*
docker-compose*
.docker

# Dependencies
node_modules
vendor
__pycache__
*.pyc

# IDE
.idea
.vscode
*.swp
*.swo

# Testing
coverage
.pytest_cache
.nyc_output

# Environment
.env
.env.*
*.local

# Logs
*.log
logs

# Build artifacts
dist
build
*.tar.gz

# Documentation
docs
*.md
!README.md

# Secrets
*.pem
*.key
secrets
```

### Runtime Security

```bash
# Run as non-root
docker run --user 1000:1000 myimage

# Read-only filesystem
docker run --read-only myimage
docker run --read-only --tmpfs /tmp myimage

# Drop capabilities
docker run --cap-drop=ALL myimage
docker run --cap-drop=ALL --cap-add=CHOWN myimage

# Security options
docker run --security-opt=no-new-privileges myimage
docker run --security-opt apparmor=docker-default myimage

# Resource limits
docker run --memory="512m" --cpus="1.0" myimage
docker run --pids-limit=100 myimage

# Network restrictions
docker run --network=none myimage

# Read-only mounts
docker run -v /host/path:/container/path:ro myimage
```

### Image Scanning

```bash
# Docker Scout (built-in)
docker scout cves myimage
docker scout recommendations myimage

# Trivy
trivy image myimage

# Snyk
snyk container test myimage

# Anchore
anchore-cli image add myimage
anchore-cli image vuln myimage
```

---

## 9. Performance Optimization

### Build Optimization

```dockerfile
# 1. Order layers from least to most frequently changed
FROM python:3.11-slim
WORKDIR /app

# Rarely changes
COPY requirements.txt .
RUN pip install -r requirements.txt

# Changes often
COPY . .

# 2. Combine RUN commands to reduce layers
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
        package1 \
        package2 && \
    rm -rf /var/lib/apt/lists/*

# 3. Use .dockerignore to reduce context size

# 4. Use BuildKit
DOCKER_BUILDKIT=1 docker build .

# 5. Use cache mounts
RUN --mount=type=cache,target=/root/.cache/pip \
    pip install -r requirements.txt
```

### Runtime Optimization

```bash
# Resource limits
docker run \
  --memory="512m" \
  --memory-swap="1g" \
  --cpus="1.5" \
  --cpu-shares=512 \
  myimage

# Logging limits
docker run \
  --log-opt max-size=10m \
  --log-opt max-file=3 \
  myimage

# Storage driver
# Use overlay2 (default on modern Docker)

# Check image size
docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"

# Analyze layers
docker history myimage
dive myimage  # Third-party tool for layer analysis
```

### Image Size Optimization

```dockerfile
# Use slim/alpine base images
FROM python:3.11-slim      # Instead of python:3.11
FROM node:18-alpine        # Instead of node:18

# Remove package manager cache
RUN apt-get update && \
    apt-get install -y package && \
    rm -rf /var/lib/apt/lists/*

RUN apk add --no-cache package  # Alpine

# Don't install dev dependencies in production
RUN npm ci --only=production

# Use multi-stage builds
FROM builder AS final
COPY --from=builder /app/dist ./dist

# Remove unnecessary files
RUN rm -rf /tmp/* /var/tmp/*
```

---

## 10. Production Patterns

### Container Orchestration Readiness

```dockerfile
# Production-ready Dockerfile
FROM python:3.11-slim AS base

# Security: Create non-root user
RUN groupadd -r app && useradd -r -g app app

# Performance: Set environment
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1

WORKDIR /app

# Dependencies first (caching)
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Application
COPY --chown=app:app . .

USER app

EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

# Graceful shutdown
STOPSIGNAL SIGTERM

CMD ["gunicorn", "--bind", "0.0.0.0:8000", "--workers", "4", "app:app"]
```

### Entrypoint Scripts

```bash
#!/bin/bash
# docker-entrypoint.sh
set -e

# Wait for dependencies
wait_for_service() {
    host=$1
    port=$2
    echo "Waiting for $host:$port..."
    while ! nc -z "$host" "$port"; do
        sleep 1
    done
    echo "$host:$port is available"
}

# Wait for database
if [ -n "$DATABASE_HOST" ]; then
    wait_for_service "$DATABASE_HOST" "${DATABASE_PORT:-5432}"
fi

# Run migrations
if [ "$RUN_MIGRATIONS" = "true" ]; then
    echo "Running migrations..."
    python manage.py migrate
fi

# Execute main command
exec "$@"
```

```dockerfile
COPY docker-entrypoint.sh /
RUN chmod +x /docker-entrypoint.sh
ENTRYPOINT ["/docker-entrypoint.sh"]
CMD ["gunicorn", "app:app"]
```

### Logging Best Practices

```dockerfile
# Log to stdout/stderr (not files)
CMD ["app", "--log-format", "json", "--log-output", "stdout"]
```

```bash
# Docker logging drivers
docker run --log-driver json-file \
  --log-opt max-size=10m \
  --log-opt max-file=3 \
  myimage

# Other drivers: syslog, journald, fluentd, awslogs, gcplogs
```

### Quick Reference

```bash
# === CONTAINER LIFECYCLE ===
docker run -d --name app -p 8080:80 nginx
docker exec -it app bash
docker logs -f app
docker stop app && docker rm app

# === IMAGES ===
docker build -t myapp:v1 .
docker push registry/myapp:v1
docker pull registry/myapp:v1
docker images && docker rmi imageid

# === VOLUMES ===
docker volume create data
docker run -v data:/app/data myapp
docker run -v $(pwd):/app myapp

# === NETWORKS ===
docker network create mynet
docker run --network mynet myapp

# === COMPOSE ===
docker compose up -d
docker compose down -v
docker compose logs -f

# === CLEANUP ===
docker system prune -af --volumes
```

---

*This guide covers Docker comprehensively. Continue to the Kubernetes guide for container orchestration.*
