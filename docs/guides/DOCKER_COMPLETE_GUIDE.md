# ğŸ³ Complete Docker Guide

A comprehensive guide covering Docker from basics to advanced production patterns.

---

## Table of Contents

1. [Docker Fundamentals](#1-docker-fundamentals)
2. [Container Lifecycle](#2-container-lifecycle)
3. [Images & Dockerfiles](#3-images--dockerfiles)
4. [Networking](#4-networking)
5. [Storage & Volumes](#5-storage--volumes)
6. [Docker Compose](#6-docker-compose)
7. [Multi-Stage Builds](#7-multi-stage-builds)
8. [Security Best Practices](#8-security-best-practices)
9. [Performance Optimization](#9-performance-optimization)
10. [Production Patterns](#10-production-patterns)

---

## 1. Docker Fundamentals

### What is Docker?

Docker is an open-source **containerization platform** that enables developers to package applications and their dependencies into lightweight, portable containers. Unlike traditional virtualization, Docker containers share the host operating system's kernel, making them significantly more efficient in terms of resource usage and startup time.

**Key Characteristics:**
- **Lightweight**: Containers share the host OS kernel, eliminating the need for a full guest OS
- **Portable**: "Build once, run anywhere" - containers work consistently across different environments
- **Isolated**: Each container has its own filesystem, network, and process space
- **Ephemeral**: Containers are designed to be temporary and easily replaceable

### Why Docker Matters

Before Docker, developers faced the infamous "it works on my machine" problem. Applications that worked perfectly in development would fail in production due to differences in:
- Operating system versions
- Library dependencies
- Configuration settings
- Environment variables

Docker solves these problems by creating a **consistent runtime environment** that travels with your application. This leads to:

1. **Faster Development Cycles**: Developers can spin up complex environments in seconds
2. **Simplified Deployment**: The same container runs identically in dev, staging, and production
3. **Better Resource Utilization**: Containers use fewer resources than VMs
4. **Microservices Architecture**: Easy to break monoliths into independently deployable services
5. **Scalability**: Quickly scale applications horizontally by running multiple container instances

### Core Concepts

#### Images
A Docker **image** is a read-only template containing instructions for creating a container. Think of it as a snapshot or blueprint of your application at a specific point in time. Images are built in **layers**, where each layer represents a filesystem change (adding files, installing packages, etc.).

- Images are **immutable** - once created, they never change
- Images are identified by a **name:tag** format (e.g., `nginx:1.25-alpine`)
- Images can be stored in **registries** like Docker Hub, GitHub Container Registry, or private registries

#### Containers
A **container** is a running instance of an image. When you start a container, Docker adds a writable layer on top of the image layers where your application can write data. Multiple containers can be created from the same image, each running independently.

- Containers are **isolated** from each other and the host system
- Containers are **ephemeral** by default - data is lost when the container is removed
- Each container gets its own **network interface**, **process tree**, and **filesystem**

#### Volumes
**Volumes** are the preferred way to persist data generated by containers. Unlike the container's writable layer, volumes exist independently of containers and can be shared between multiple containers.

#### Networks
Docker **networks** enable containers to communicate with each other and the outside world. Docker provides several network drivers (bridge, host, overlay) for different use cases.

### Architecture

Docker uses a **client-server architecture**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         Docker Host                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                     Docker Daemon                          â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚ â”‚
â”‚  â”‚  â”‚   Images    â”‚ â”‚ Containers  â”‚ â”‚      Networks       â”‚  â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚ â”‚
â”‚  â”‚  â”‚   Volumes   â”‚ â”‚   Plugins   â”‚ â”‚     BuildKit        â”‚  â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â–²                                  â”‚
â”‚                              â”‚ REST API                         â”‚
â”‚                              â–¼                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                     Docker CLI                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Components:**
- **Docker Client (docker)**: The command-line tool users interact with. It sends commands to the Docker daemon via REST API.
- **Docker Daemon (dockerd)**: The background service that manages images, containers, networks, and volumes. It listens for API requests and handles container lifecycle operations.
- **Docker Registry**: A service for storing and distributing Docker images. Docker Hub is the default public registry.
- **BuildKit**: Docker's modern build engine that provides improved performance, caching, and security features.

### Container vs VM: A Deep Dive

Understanding the difference between containers and virtual machines is crucial:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Virtual Machine    â”‚     â”‚        Container        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”  â”‚     â”‚  â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”  â”‚
â”‚  â”‚App1â”‚ â”‚App2â”‚ â”‚App3â”‚  â”‚     â”‚  â”‚App1â”‚ â”‚App2â”‚ â”‚App3â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”¤ â”œâ”€â”€â”€â”€â”¤ â”œâ”€â”€â”€â”€â”¤  â”‚     â”‚  â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜  â”‚
â”‚  â”‚Binsâ”‚ â”‚Binsâ”‚ â”‚Binsâ”‚  â”‚     â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚Libsâ”‚ â”‚Libsâ”‚ â”‚Libsâ”‚  â”‚     â”‚  â”‚     Docker Engine   â”‚â”‚
â”‚  â”œâ”€â”€â”€â”€â”¤ â”œâ”€â”€â”€â”€â”¤ â”œâ”€â”€â”€â”€â”¤  â”‚     â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚  â”‚ OS â”‚ â”‚ OS â”‚ â”‚ OS â”‚  â”‚     â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜  â”‚     â”‚  â”‚      Host OS        â”‚â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚     â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚  â”‚     Hypervisor      â”‚â”‚     â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚     â”‚  â”‚      Hardware       â”‚â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚     â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚  â”‚      Hardware       â”‚â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       Heavy & Slow                  Light & Fast
```

| Aspect | Virtual Machines | Containers |
|--------|-----------------|------------|
| **Isolation** | Full OS-level isolation | Process-level isolation |
| **Boot Time** | Minutes | Seconds (milliseconds) |
| **Size** | Gigabytes | Megabytes |
| **Resource Usage** | High (full OS overhead) | Low (shared kernel) |
| **Portability** | Limited | Highly portable |
| **Use Case** | Running different OS, legacy apps | Microservices, modern apps |

**When to use VMs:**
- Running applications that require different operating systems
- Applications that need complete kernel isolation for security
- Legacy applications that can't be containerized

**When to use Containers:**
- Microservices architectures
- CI/CD pipelines
- Development environments
- Cloud-native applications

### How Docker Isolation Works

Docker leverages several Linux kernel features to provide container isolation:

1. **Namespaces**: Provide isolated views of system resources
   - `pid` - Process isolation
   - `net` - Network isolation
   - `mnt` - Mount point isolation
   - `uts` - Hostname isolation
   - `ipc` - Inter-process communication isolation
   - `user` - User ID isolation

2. **Control Groups (cgroups)**: Limit and account for resource usage
   - CPU limits
   - Memory limits
   - I/O limits
   - Network bandwidth limits

3. **Union Filesystems**: Enable layered, copy-on-write file systems
   - OverlayFS (default)
   - Efficient storage using image layers

### Installation

```bash
# Ubuntu/Debian
curl -fsSL https://get.docker.com | sh
sudo usermod -aG docker $USER
newgrp docker

# Verify installation
docker --version
docker info
docker run hello-world

# Enable Docker at boot
sudo systemctl enable docker
sudo systemctl start docker
```

---

## 2. Container Lifecycle

### The Philosophy Behind Container Lifecycle

Containers represent a fundamental shift in how we think about running software. Unlike traditional servers or virtual machines that are treated as long-lived entities, containers embrace **immutability** and **disposability** as core principles.

**The Immutable Infrastructure Paradigm:**

In traditional infrastructure, when something goes wrong with a server, operators SSH in, diagnose the issue, apply fixes, and hope everything works. This creates **configuration drift** â€“ the actual state of the server slowly diverges from the intended state documented in scripts or runbooks.

Containers flip this model. Instead of fixing a broken container, you simply:
1. **Destroy** the problematic container
2. **Create** a new one from the same image

This approach is called **immutable infrastructure** because:
- The image (blueprint) never changes after it's built
- Running containers are never modified in place
- All changes require building a new image and redeploying

**Why This Matters:**

| Traditional Approach | Container Approach |
|---------------------|-------------------|
| "The server has been running for 847 days" is a badge of honor | Long-running containers are a smell â€“ they might have drifted |
| Manual hotfixes applied directly to production | All changes go through CI/CD pipeline |
| Difficult to reproduce issues ("works on my machine") | Same image runs identically everywhere |
| Rollback requires careful undoing of changes | Rollback = deploy the previous image |

### Understanding Container States

A container's lifecycle goes through several well-defined states. Understanding these states is crucial for debugging, orchestration, and designing resilient applications.

**What Happens at Each State Transition (Under the Hood):**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   CONTAINER STATE MACHINE                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    docker run    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚    â”‚ Created â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Running â”‚                     â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                     â”‚
â”‚         â–²                             â”‚                          â”‚
â”‚         â”‚ docker create              â”‚ docker pause              â”‚
â”‚         â”‚                             â–¼                          â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚    â”‚  Image  â”‚                  â”‚ Paused  â”‚                     â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                     â”‚
â”‚                                       â”‚ docker unpause           â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    docker start       â–¼                          â”‚
â”‚    â”‚ Stopped â”‚ â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚    â”‚ (Exited)â”‚                  â”‚ Running â”‚                     â”‚
â”‚    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                     â”‚
â”‚         â”‚                             â”‚                          â”‚
â”‚         â”‚ docker rm                   â”‚ docker stop/kill         â”‚
â”‚         â–¼                             â–¼                          â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚    â”‚ Removed â”‚                  â”‚ Stopped â”‚                     â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Container States Explained:**

| State | Description |
|-------|-------------|
| **Created** | Container exists but hasn't started yet. The filesystem is ready, but no process is running. |
| **Running** | Container's main process (PID 1) is actively executing. This is the normal operational state. |
| **Paused** | Container's processes are suspended using cgroups freezer. Memory state is preserved but no CPU time is allocated. |
| **Stopped/Exited** | Main process has terminated. Container still exists with its filesystem intact. Exit code indicates success (0) or failure (non-zero). |
| **Removed** | Container is deleted. Filesystem and metadata are gone (unless volumes were used). |

**What Happens During Each Transition (Deep Dive):**

Understanding what Docker does internally helps you debug issues and design better container architectures:

**1. Image â†’ Created (`docker create`):**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ When you run 'docker create', Docker:                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. Generates a unique container ID (64 hex characters)          â”‚
â”‚ 2. Creates a writable layer on top of image layers              â”‚
â”‚ 3. Allocates network namespace (but doesn't configure it yet)   â”‚
â”‚ 4. Prepares mount points for volumes                             â”‚
â”‚ 5. Records container metadata in /var/lib/docker/containers/    â”‚
â”‚ 6. Does NOT start any processes                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**2. Created â†’ Running (`docker start`):**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ When you run 'docker start', Docker:                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. Creates Linux namespaces (pid, net, mnt, uts, ipc, user)     â”‚
â”‚ 2. Sets up cgroups for resource limits                          â”‚
â”‚ 3. Configures network interface and assigns IP                  â”‚
â”‚ 4. Mounts the layered filesystem using OverlayFS                â”‚
â”‚ 5. Mounts volumes at specified paths                            â”‚
â”‚ 6. Executes the ENTRYPOINT/CMD as PID 1 inside container        â”‚
â”‚ 7. Container process becomes a child of containerd-shim         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**3. Running â†’ Stopped (`docker stop` vs `docker kill`):**

| Command | Signal Sent | Grace Period | Use Case |
|---------|-------------|--------------|----------|
| `docker stop` | SIGTERM, then SIGKILL | 10 seconds (configurable) | Graceful shutdown â€“ allows cleanup |
| `docker kill` | SIGKILL | None | Immediate termination â€“ when container is stuck |

```bash
# Graceful stop with custom timeout
docker stop --time 30 mycontainer  # Wait 30 seconds before SIGKILL

# Why this matters: Databases, web servers, and queues need time to:
# - Finish processing current requests
# - Flush writes to disk
# - Close network connections gracefully
# - Notify peers they're going away
```

**4. Running â†’ Paused (`docker pause`):**

The pause feature uses the **cgroups freezer** subsystem. When paused:
- All processes in the container are suspended (SIGSTOP equivalent)
- Memory is preserved exactly as-is
- No CPU cycles are consumed
- Network connections remain open but no data is processed
- File descriptors remain valid

**Use cases for pausing:**
- Debugging: Freeze state to inspect
- Resource management: Temporarily free CPU for other work
- Snapshotting: Create consistent filesystem snapshot
- Testing: Simulate network partitions

### The Ephemeral Nature of Containers

Containers are designed to be **ephemeral** â€“ they can be stopped, destroyed, and replaced by a new instance at any time. This design principle has profound implications:

**What This Means in Practice:**
- ğŸ“¦ **Stateless by Default**: Containers should not store important data in their writable layer
- ğŸ”„ **Replaceable**: If a container is unhealthy, destroy it and create a new one
- ğŸš€ **Fast Recovery**: Starting a new container is faster than fixing a broken one
- ğŸ“Š **Scalable**: Run multiple identical containers behind a load balancer

**The "Cattle vs Pets" Philosophy:**

| Traditional Servers (Pets) | Containers (Cattle) |
|---------------------------|---------------------|
| Named individually (db-server-01) | Numbered (container-a1b2c3) |
| Nursed back to health when sick | Replaced when unhealthy |
| Carefully maintained | Recreated from images |
| Downtime for updates | Rolling updates with zero downtime |

### Container Isolation Levels

Container isolation is what makes containers secure and predictable. Docker leverages **Linux kernel features** that have existed for years, combining them into a cohesive container runtime. Understanding these mechanisms helps you design secure applications and debug isolation-related issues.

**The Two Pillars of Container Isolation:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               CONTAINER ISOLATION ARCHITECTURE                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚      NAMESPACES         â”‚            CGROUPS                     â”‚
â”‚  (What you can see)     â”‚     (What you can use)                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ Isolate VISIBILITY    â”‚ â€¢ Isolate RESOURCES                   â”‚
â”‚ â€¢ Process trees         â”‚ â€¢ CPU time                            â”‚
â”‚ â€¢ Network interfaces    â”‚ â€¢ Memory                              â”‚
â”‚ â€¢ File systems          â”‚ â€¢ Disk I/O                            â”‚
â”‚ â€¢ User IDs              â”‚ â€¢ Network bandwidth                   â”‚
â”‚ â€¢ Hostnames             â”‚ â€¢ Process count                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Namespaces Explained In Detail:**

| Namespace | What It Isolates | Why It Matters |
|-----------|-----------------|----------------|
| **PID Namespace** | Process IDs | Container sees its own process as PID 1. Cannot see or signal host processes. |
| **Network Namespace** | Network stack | Container has own IP, routing table, firewall rules. Host ports are separate. |
| **Mount Namespace** | Filesystem mounts | Container has own root filesystem. Cannot access host files unless mounted. |
| **User Namespace** | User and group IDs | Root (UID 0) inside container can map to unprivileged user on host. |
| **UTS Namespace** | Hostname/domain | Each container can have unique hostname without affecting host. |
| **IPC Namespace** | Inter-process comms | Shared memory and semaphores are isolated between containers. |

**How PID Namespace Works:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PID NAMESPACE ISOLATION                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚    HOST VIEW:                         CONTAINER VIEW:           â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚    â”‚ PID 1: systemd     â”‚             â”‚ PID 1: nginx       â”‚   â”‚
â”‚    â”‚ PID 500: dockerd   â”‚             â”‚ PID 2: nginx workerâ”‚   â”‚
â”‚    â”‚ PID 1234: nginx â†â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚   â”‚
â”‚    â”‚                    â”‚             â”‚                    â”‚ â”‚   â”‚
â”‚    â”‚ (container's nginx â”‚             â”‚ (nginx sees itself â”‚ â”‚   â”‚
â”‚    â”‚  is just another   â”‚             â”‚  as PID 1, the     â”‚ â”‚   â”‚
â”‚    â”‚  process, PID 1234)â”‚             â”‚  init process)     â”‚ â”‚   â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                  â”‚
â”‚    Security Implication: Container cannot kill host processes   â”‚
â”‚    because it cannot even see them!                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**PID 1 Special Responsibilities:**
When your application runs as PID 1 inside a container, it has special responsibilities:
- **Signal Handling**: Must handle SIGTERM for graceful shutdown (default behavior often ignores it!)
- **Zombie Reaping**: Must call `wait()` on child processes to prevent zombies
- **This is why many images use** `tini` or `dumb-init` as an init process

**Cgroups (Control Groups) Explained:**

Cgroups limit, prioritize, and account for resource usage:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      CGROUPS HIERARCHY                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚    /sys/fs/cgroup/                                              â”‚
â”‚    â”œâ”€â”€ cpu/                                                     â”‚
â”‚    â”‚   â””â”€â”€ docker/                                              â”‚
â”‚    â”‚       â””â”€â”€ <container-id>/                                  â”‚
â”‚    â”‚           â”œâ”€â”€ cpu.shares      (relative CPU weight)        â”‚
â”‚    â”‚           â”œâ”€â”€ cpu.cfs_quota   (hard CPU limit)             â”‚
â”‚    â”‚           â””â”€â”€ cpu.cfs_period  (quota period)               â”‚
â”‚    â”œâ”€â”€ memory/                                                  â”‚
â”‚    â”‚   â””â”€â”€ docker/                                              â”‚
â”‚    â”‚       â””â”€â”€ <container-id>/                                  â”‚
â”‚    â”‚           â”œâ”€â”€ memory.limit    (max memory)                 â”‚
â”‚    â”‚           â”œâ”€â”€ memory.usage    (current usage)              â”‚
â”‚    â”‚           â””â”€â”€ memory.oom_control (OOM behavior)            â”‚
â”‚    â””â”€â”€ blkio/                                                   â”‚
â”‚        â””â”€â”€ docker/                                              â”‚
â”‚            â””â”€â”€ <container-id>/                                  â”‚
â”‚                â””â”€â”€ blkio.throttle  (disk I/O limits)            â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**What Happens When Limits Are Exceeded:**

| Resource | When Limit Exceeded | Container Behavior |
|----------|--------------------|--------------------|
| **Memory** | Container uses more than `--memory` limit | OOM killer terminates container (exit code 137) |
| **CPU** | Container tries to use more than `--cpus` | Container is throttled, not killed |
| **PIDs** | More processes than `--pids-limit` | fork() calls fail with EAGAIN |
| **Disk I/O** | Exceeds `--device-read-bps` or `--device-write-bps` | I/O operations are throttled |

**Security Layers Beyond Namespaces:**

Docker adds additional security mechanisms:

| Layer | Purpose | Default State |
|-------|---------|---------------|
| **Seccomp** | Filters dangerous system calls | Enabled (blocks ~44 syscalls) |
| **AppArmor/SELinux** | Mandatory access control | Enabled on supported systems |
| **Capabilities** | Fine-grained root privileges | Only essential caps granted |
| **Read-only rootfs** | Prevents filesystem modification | Optional (`--read-only`) |

### Running Containers

The `docker run` command combines multiple operations: pulling an image (if needed), creating a container, and starting it.

```bash
# Basic run
docker run nginx                         # Run nginx (foreground)
docker run -d nginx                      # Run in background (detached)
docker run -d --name webserver nginx     # With custom name
docker run -d -p 8080:80 nginx           # Map port 8080 to container port 80
docker run -it ubuntu bash               # Interactive terminal

# Run options
docker run -d \
  --name myapp \
  --hostname myapp \
  -p 8080:80 \
  -p 8443:443 \
  -v /host/data:/container/data \
  -v named_volume:/data \
  -e "NODE_ENV=production" \
  -e "API_KEY=secret" \
  --env-file .env \
  -w /app \
  --user 1000:1000 \
  --restart unless-stopped \
  --memory="512m" \
  --cpus="1.0" \
  --network mynetwork \
  --health-cmd="curl -f http://localhost/ || exit 1" \
  --health-interval=30s \
  nginx:alpine
```

**Understanding Key Run Options:**

| Option | Purpose | When to Use |
|--------|---------|-------------|
| `-d` (detach) | Run in background | Production servers, long-running services |
| `-it` (interactive tty) | Attach terminal | Debugging, running commands |
| `-p host:container` | Port mapping | Exposing services to host/network |
| `-v` (volume) | Mount storage | Persisting data, sharing files |
| `-e` (env) | Set variables | Configuration, secrets |
| `--restart` | Auto-restart policy | Production reliability |
| `--memory/--cpus` | Resource limits | Preventing resource exhaustion |
| `--network` | Network attachment | Multi-container communication |

### Container Management

```bash
# List containers
docker ps                    # Running containers
docker ps -a                 # All containers (including stopped)
docker ps -q                 # Only container IDs
docker ps -s                 # With size

# Container information
docker inspect container_name
docker logs container_name
docker logs -f container_name        # Follow logs
docker logs --tail 100 container_name
docker logs --since="2023-01-01" container_name

# Container status
docker stats                 # Live resource usage
docker top container_name    # Running processes

# Execute commands
docker exec container_name command
docker exec -it container_name bash
docker exec -u root container_name command

# Container lifecycle
docker start container_name
docker stop container_name
docker restart container_name
docker pause container_name
docker unpause container_name
docker kill container_name

# Remove containers
docker rm container_name
docker rm -f container_name          # Force remove running container
docker rm $(docker ps -aq)           # Remove all stopped containers
docker container prune               # Remove all stopped containers
```

### Copy Files

```bash
# Copy from host to container
docker cp file.txt container_name:/path/to/dest/

# Copy from container to host
docker cp container_name:/path/to/file.txt ./local/

# Copy entire directories
docker cp container_name:/var/log/ ./logs/
```

---

## 3. Images & Dockerfiles

### Understanding Docker Images

A Docker image is much more than just a file â€“ it's a **layered, immutable snapshot** of a filesystem along with metadata describing how to run it. Understanding image architecture is fundamental to efficient Docker usage.

**The Anatomy of a Docker Image:**

A Docker image consists of several key components:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DOCKER IMAGE ANATOMY                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚                    IMAGE MANIFEST                           â”‚â”‚
â”‚  â”‚  - JSON document describing the image                       â”‚â”‚
â”‚  â”‚  - Lists all layers (as SHA256 digests)                    â”‚â”‚
â”‚  â”‚  - Specifies target architecture (amd64, arm64)            â”‚â”‚
â”‚  â”‚  - References the config blob                               â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                              â”‚                                   â”‚
â”‚                              â–¼                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚                    CONFIG BLOB                              â”‚â”‚
â”‚  â”‚  - Created timestamp                                        â”‚â”‚
â”‚  â”‚  - Author information                                       â”‚â”‚
â”‚  â”‚  - Default environment variables                            â”‚â”‚
â”‚  â”‚  - Default command (CMD) and entrypoint                    â”‚â”‚
â”‚  â”‚  - Exposed ports, volumes, labels                          â”‚â”‚
â”‚  â”‚  - Build history (each Dockerfile instruction)             â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                              â”‚                                   â”‚
â”‚                              â–¼                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚                    LAYER BLOBS                              â”‚â”‚
â”‚  â”‚  - Compressed tar archives (tar.gz)                        â”‚â”‚
â”‚  â”‚  - Each contains filesystem changes from one instruction   â”‚â”‚
â”‚  â”‚  - Identified by SHA256 content hash                       â”‚â”‚
â”‚  â”‚  - Stored in /var/lib/docker/overlay2/                     â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Content-Addressable Storage:**

Docker uses **content-addressable storage**, meaning every piece of data is identified by a cryptographic hash (SHA256) of its contents. This has profound implications:

| Concept | How It Works | Benefit |
|---------|-------------|---------|
| **Deduplication** | Same content = same hash = stored only once | Multiple images sharing Ubuntu base use ONE copy |
| **Integrity** | Hash validates content hasn't been corrupted | Tampered images fail verification |
| **Caching** | Same Dockerfile instruction + same input = same hash | Rebuilds skip unchanged layers |
| **Distribution** | Registry stores layers by hash | Pull only layers you don't have locally |

**Understanding Copy-on-Write (CoW):**

When a container runs, Docker creates a thin writable layer on top of the image layers using **OverlayFS** (or other storage drivers). This uses the copy-on-write strategy:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    COPY-ON-WRITE EXPLAINED                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚    READ operation:                                               â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                          â”‚
â”‚    â”‚  Upper (RW)     â”‚â”€â”€â”€ File not here? â”€â”€â–¶ Look in lower     â”‚
â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                                          â”‚
â”‚    â”‚  Lower (RO)     â”‚â”€â”€â”€ Found! Read from here (fast)         â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                          â”‚
â”‚                                                                  â”‚
â”‚    WRITE operation (modifying existing file):                    â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                          â”‚
â”‚    â”‚  Upper (RW)     â”‚â—€â”€â”€ 2. Write modified copy here          â”‚
â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                                          â”‚
â”‚    â”‚  Lower (RO)     â”‚â”€â”€â”€ 1. Copy file up (copy-on-write)      â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                          â”‚
â”‚                                                                  â”‚
â”‚    DELETE operation:                                             â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                          â”‚
â”‚    â”‚  Upper (RW)     â”‚â—€â”€â”€ Create "whiteout" file (marks deleted)â”‚
â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                                          â”‚
â”‚    â”‚  Lower (RO)     â”‚â”€â”€â”€ Original file untouched              â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                          â”‚
â”‚                                                                  â”‚
â”‚    Key Insight: Lower layers NEVER change, enabling sharing!    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Why Image Immutability Matters:**

| Scenario | Without Immutability | With Immutability |
|----------|---------------------|-------------------|
| Reproducing bugs | "The image was different when we deployed" | Same SHA256 = exact same image, always |
| Security scanning | "We scanned it, but then it changed" | Scanned image hash matches deployed hash |
| Rollbacks | "I hope the old version still exists somewhere" | Every version is a distinct, preserved image |
| Caching | "Rebuild everything just in case" | Unchanged layers = cache hits |

**Image Layers Explained:**

Every Docker image consists of multiple read-only layers stacked on top of each other. Each layer represents a filesystem change from a Dockerfile instruction.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    IMAGE LAYER ARCHITECTURE                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚    Container (running)                                          â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚    â”‚  Writable Layer (Container Layer)                      â”‚   â”‚
â”‚    â”‚  - All container writes go here                        â”‚   â”‚
â”‚    â”‚  - Deleted when container is removed                   â”‚   â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                           â–²                                     â”‚
â”‚    Image (read-only)      â”‚                                     â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚    â”‚  Layer 4: CMD ["nginx", "-g", "daemon off;"]          â”‚   â”‚
â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚    â”‚  Layer 3: COPY ./app /usr/share/nginx/html            â”‚   â”‚
â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚    â”‚  Layer 2: RUN apt-get install nginx                   â”‚   â”‚
â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚    â”‚  Layer 1: FROM ubuntu:22.04 (base image)              â”‚   â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Why Layers Matter:**

| Benefit | Explanation |
|---------|-------------|
| **Sharing** | Multiple images can share the same base layers, saving disk space |
| **Caching** | Docker caches layers, so rebuilds only recreate changed layers |
| **Distribution** | Only new/changed layers need to be transferred when pulling |
| **Immutability** | Layers never change after creation, ensuring consistency |

### Image Tags and Naming

Docker images use a naming convention that identifies where images come from and which version to use:

```
[registry/][repository/]name[:tag][@digest]
```

**Examples Explained:**

| Full Name | Registry | Repository | Image | Tag |
|-----------|----------|------------|-------|-----|
| `nginx` | Docker Hub (default) | library (official) | nginx | latest (default) |
| `nginx:1.25-alpine` | Docker Hub | library | nginx | 1.25-alpine |
| `myuser/myapp:v1.0` | Docker Hub | myuser | myapp | v1.0 |
| `gcr.io/project/app:latest` | gcr.io | project | app | latest |
| `localhost:5000/myimage` | localhost:5000 | - | myimage | latest |

**Tag Best Practices:**
- âŒ **Avoid `latest`** in production â€“ it's unpredictable
- âœ… Use **semantic versioning** (`v1.2.3`) for releases
- âœ… Use **Git SHA** for CI/CD builds for traceability
- âœ… Use **date-based** tags for nightly builds

### Image Registries

A registry is a storage and distribution system for Docker images. Understanding registries is essential for sharing and deploying containers.

| Registry | URL | Use Case |
|----------|-----|----------|
| **Docker Hub** | hub.docker.com | Default public registry, official images |
| **GitHub Container Registry** | ghcr.io | GitHub integration, private repos |
| **Amazon ECR** | *.dkr.ecr.*.amazonaws.com | AWS-native, integrated with ECS/EKS |
| **Google Container Registry** | gcr.io | GCP-native, integrated with GKE |
| **Azure Container Registry** | *.azurecr.io | Azure-native, integrated with AKS |
| **Harbor** | self-hosted | Open-source, enterprise features |

### Image Management

```bash
# Pull images
docker pull nginx                    # Latest tag
docker pull nginx:1.25               # Specific version
docker pull nginx:alpine             # Alpine variant
docker pull gcr.io/google-containers/nginx  # From other registry

# List images
docker images
docker images -a                     # Include intermediate images
docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"

# Image information
docker inspect nginx
docker history nginx                 # Show layers

# Remove images
docker rmi nginx
docker rmi -f nginx                  # Force remove
docker rmi $(docker images -q)       # Remove all images
docker image prune                   # Remove unused images
docker image prune -a                # Remove all unused images

# Tag and push
docker tag myapp:latest myregistry/myapp:v1.0
docker push myregistry/myapp:v1.0

# Save and load
docker save -o myimage.tar myimage:latest
docker load -i myimage.tar

# Export and import (container filesystem)
docker export container_name > container.tar
docker import container.tar newimage:tag
```

### Dockerfile Syntax

```dockerfile
# ============================================
# Complete Dockerfile Reference
# ============================================

# Base image (required first instruction)
FROM ubuntu:22.04
FROM python:3.11-slim AS builder
FROM scratch                          # Empty base image

# Metadata
LABEL maintainer="you@example.com"
LABEL version="1.0"
LABEL description="My application"

# Arguments (build-time variables)
ARG VERSION=1.0
ARG BUILD_DATE

# Environment variables
ENV NODE_ENV=production
ENV APP_HOME=/app
ENV PATH="$APP_HOME/bin:$PATH"

# Working directory
WORKDIR /app

# Copy files
COPY . .                              # Copy all
COPY package*.json ./                 # Copy specific files
COPY --chown=user:group src/ ./src/   # With ownership
COPY --from=builder /app/dist ./dist  # Multi-stage copy

# Add files (can extract tar and download URLs)
ADD archive.tar.gz /opt/
ADD https://example.com/file.tar.gz /opt/

# Run commands
RUN apt-get update && apt-get install -y \
    package1 \
    package2 \
    && rm -rf /var/lib/apt/lists/*

# Create user
RUN groupadd -r appgroup && useradd -r -g appgroup appuser

# Switch user
USER appuser

# Expose ports (documentation)
EXPOSE 80
EXPOSE 443

# Volumes
VOLUME /data
VOLUME ["/var/log", "/var/data"]

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost/ || exit 1

# Default command
CMD ["nginx", "-g", "daemon off;"]

# Entrypoint (not overridden by docker run arguments)
ENTRYPOINT ["python", "app.py"]
ENTRYPOINT ["/docker-entrypoint.sh"]

# Combine ENTRYPOINT and CMD
ENTRYPOINT ["python", "app.py"]
CMD ["--help"]                        # Default args, can be overridden

# Stop signal
STOPSIGNAL SIGTERM

# Shell form vs exec form
RUN apt-get update               # Shell form (runs in /bin/sh -c)
RUN ["apt-get", "update"]        # Exec form (no shell)
```

### Complete Dockerfile Examples

**Python Application:**

This example demonstrates a production-ready Python Dockerfile with all best practices:

```dockerfile
# --------------------------------------------------------
# BASE IMAGE
# --------------------------------------------------------
# Using python:3.11-slim instead of python:3.11 reduces image size
# from ~900MB to ~120MB. "slim" variants exclude dev tools.
FROM python:3.11-slim

# --------------------------------------------------------
# ENVIRONMENT VARIABLES
# --------------------------------------------------------
# PYTHONDONTWRITEBYTECODE=1: Prevents Python from creating .pyc files
#   (bytecode cache), reducing container size and avoiding permission issues.
#
# PYTHONUNBUFFERED=1: Forces stdout/stderr to be unbuffered, so logs
#   appear immediately in `docker logs` without delay.
#
# PIP_NO_CACHE_DIR=1: Prevents pip from caching downloaded packages,
#   reducing image size since cached packages aren't needed at runtime.
#
# PIP_DISABLE_PIP_VERSION_CHECK=1: Stops pip from checking for updates,
#   making builds faster and more deterministic.
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PIP_NO_CACHE_DIR=1 \
    PIP_DISABLE_PIP_VERSION_CHECK=1

# --------------------------------------------------------
# WORKING DIRECTORY
# --------------------------------------------------------
# Sets /app as the working directory. All subsequent commands
# (COPY, RUN, CMD) will execute relative to this path.
WORKDIR /app

# --------------------------------------------------------
# DEPENDENCY INSTALLATION (CACHE OPTIMIZATION)
# --------------------------------------------------------
# Copy ONLY requirements.txt first, before the full application code.
# Docker caches each layer. If requirements.txt hasn't changed,
# Docker reuses the cached pip install layer, making rebuilds
# much faster (seconds instead of minutes).
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# --------------------------------------------------------
# APPLICATION CODE
# --------------------------------------------------------
# Now copy the rest of the application. This layer will be
# rebuilt on every code change, but dependencies above are cached.
COPY . .

# --------------------------------------------------------
# SECURITY: NON-ROOT USER
# --------------------------------------------------------
# Running as root in containers is a security risk. If an attacker
# escapes the container, they'd have root access to the host.
# Creating a dedicated user with minimal privileges mitigates this.
#
# groupadd -r: Create a system group (-r means no home directory)
# useradd -r: Create a system user
# -g appgroup: Add user to the appgroup
# chown -R: Change ownership of /app to the new user
RUN groupadd -r appgroup && useradd -r -g appgroup appuser \
    && chown -R appuser:appgroup /app
USER appuser

# --------------------------------------------------------
# PORT DOCUMENTATION
# --------------------------------------------------------
# EXPOSE is documentation only - it doesn't actually publish the port.
# You still need -p 8000:8000 when running. But it tells users and
# tools which port the application uses.
EXPOSE 8000

# --------------------------------------------------------
# HEALTH CHECK
# --------------------------------------------------------
# Kubernetes and Docker use this to determine if the container is healthy.
# --interval=30s: Check every 30 seconds
# --timeout=3s:   Fail if check takes longer than 3 seconds
# --start-period=5s: Wait 5s after container starts before checking
#                    (gives app time to initialize)
# --retries=3: Mark unhealthy after 3 consecutive failures
#
# The check itself makes an HTTP request to /health endpoint.
# exit 1 signals unhealthy, exit 0 signals healthy.
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD python -c "import urllib.request; urllib.request.urlopen('http://localhost:8000/health')" || exit 1

# --------------------------------------------------------
# STARTUP COMMAND
# --------------------------------------------------------
# CMD defines the default command when container starts.
# Using exec form (JSON array) is preferred over shell form because:
# 1. No shell interpretation of special characters
# 2. Signals (SIGTERM) go directly to the process, enabling graceful shutdown
#
# gunicorn: Production WSGI server for Python apps
# --bind 0.0.0.0:8000: Listen on all interfaces (required in containers)
# app:create_app(): Application factory pattern
CMD ["gunicorn", "--bind", "0.0.0.0:8000", "app:create_app()"]
```

**Node.js Application:**
```dockerfile
FROM node:18-alpine

WORKDIR /app

# Install dependencies
COPY package*.json ./
RUN npm ci --only=production

# Copy application
COPY . .

# Create non-root user
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nextjs -u 1001 -G nodejs
USER nextjs

EXPOSE 3000

HEALTHCHECK --interval=30s --timeout=3s \
    CMD wget --no-verbose --tries=1 --spider http://localhost:3000/health || exit 1

CMD ["node", "server.js"]
```

**Go Application:**
```dockerfile
# Build stage
FROM golang:1.21-alpine AS builder

WORKDIR /app

# Download dependencies
COPY go.mod go.sum ./
RUN go mod download

# Build
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -ldflags="-w -s" -o /app/main

# Runtime stage
FROM scratch

COPY --from=builder /app/main /main
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/

EXPOSE 8080

ENTRYPOINT ["/main"]
```

### Build Commands

```bash
# Basic build
docker build -t myapp .
docker build -t myapp:v1.0 .
docker build -f Dockerfile.prod -t myapp .

# Build with arguments
docker build --build-arg VERSION=1.0 -t myapp .

# Build with no cache
docker build --no-cache -t myapp .

# Build with target (multi-stage)
docker build --target builder -t myapp:build .

# Build with platform
docker build --platform linux/amd64 -t myapp .

# BuildKit (faster, better caching)
DOCKER_BUILDKIT=1 docker build -t myapp .
```

---

## 4. Networking

### Understanding Container Networking

Docker networking allows containers to communicate with each other and the outside world. Understanding the networking model is crucial for designing microservices architectures.

**Why Container Networking Is Different:**

Containers don't have their own physical network interfaces. Instead, Docker creates **virtual networks** using Linux kernel features. When you run a container, Docker must solve three fundamental challenges:

| Challenge | What It Means | Docker's Solution |
|-----------|---------------|-------------------|
| **Isolation** | Containers shouldn't see each other's traffic by default | Network namespaces create isolated network stacks |
| **Connectivity** | Containers need to communicate when desired | Virtual ethernet pairs (veth) connect containers |
| **External Access** | Containers need to reach the internet | NAT/masquerading through host's network |

**The Linux Networking Stack Behind Docker:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              DOCKER NETWORKING INTERNALS                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚    Container A                    Container B                    â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚    â”‚ eth0         â”‚              â”‚ eth0         â”‚               â”‚
â”‚    â”‚ 172.17.0.2   â”‚              â”‚ 172.17.0.3   â”‚               â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚           â”‚                             â”‚                        â”‚
â”‚           â”‚ veth pair                   â”‚ veth pair              â”‚
â”‚           â”‚                             â”‚                        â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚    â”‚         DOCKER BRIDGE (docker0)           â”‚                â”‚
â”‚    â”‚              172.17.0.1                   â”‚                â”‚
â”‚    â”‚   (Linux bridge - like a virtual switch) â”‚                â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                         â”‚                                        â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚    â”‚             IPTABLES NAT                   â”‚                â”‚
â”‚    â”‚  - MASQUERADE outbound container traffic  â”‚                â”‚
â”‚    â”‚  - DNAT port mappings to containers       â”‚                â”‚
â”‚    â”‚  - FORWARD rules for inter-container      â”‚                â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                         â”‚                                        â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚    â”‚         HOST NETWORK INTERFACE            â”‚                â”‚
â”‚    â”‚    (eth0, en0, etc. - to internet)        â”‚                â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Understanding veth Pairs:**

A **veth pair** is like a virtual ethernet cable with two ends. Docker creates one for each container:
- One end goes inside the container (appears as `eth0`)
- Other end attaches to the Docker bridge (named `vethXXXXXX` on host)
- Packets sent to one end emerge from the other

```bash
# See veth pairs on host
ip link show type veth

# See which container a veth belongs to
docker exec <container> cat /sys/class/net/eth0/iflink
# Match that number with the interface on host
```

**The Container Network Model (CNM):**

Docker implements its own networking model called the Container Network Model (CNM), which consists of three building blocks:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  CONTAINER NETWORK MODEL (CNM)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   SANDBOX (Network Namespace)                             â”‚  â”‚
â”‚  â”‚   - Isolated network stack                                â”‚  â”‚
â”‚  â”‚   - Contains interfaces, routes, DNS                      â”‚  â”‚
â”‚  â”‚   - Each container has its own sandbox                    â”‚  â”‚
â”‚  â”‚                                                           â”‚  â”‚
â”‚  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
â”‚  â”‚   â”‚  ENDPOINTS                                       â”‚   â”‚  â”‚
â”‚  â”‚   â”‚  - Virtual network interfaces (veth pairs)       â”‚   â”‚  â”‚
â”‚  â”‚   â”‚  - One end in container, one in Docker network   â”‚   â”‚  â”‚
â”‚  â”‚   â”‚  - Containers can have multiple endpoints        â”‚   â”‚  â”‚
â”‚  â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                              â”‚                                   â”‚
â”‚                              â–¼                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   NETWORK                                                 â”‚  â”‚
â”‚  â”‚   - Group of endpoints that can communicate               â”‚  â”‚
â”‚  â”‚   - Implemented by network drivers                        â”‚  â”‚
â”‚  â”‚   - Provides DNS resolution between containers            â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Network Drivers Explained

Docker provides several network drivers for different use cases. Understanding when to use each is crucial:

| Driver | Description | Use Cases |
|--------|-------------|-----------|
| **bridge** | Default. Creates a private internal network on the host. Containers connect via virtual bridge (docker0). | Single-host development, isolated applications |
| **host** | Removes network isolation. Container uses host's network directly. Better performance but no isolation. | Performance-critical applications, debugging |
| **none** | Completely disables networking. Container has only loopback interface. | Maximum security, offline processing |
| **overlay** | Enables multi-host networking. Creates distributed network across Docker swarm nodes. | Docker Swarm, multi-node clusters |
| **macvlan** | Assigns a MAC address to container, making it appear as physical device on network. | Legacy applications requiring direct network access |
| **ipvlan** | Similar to macvlan but shares MAC address. Useful when MAC limits exist. | Environments with MAC address restrictions |

**Bridge Driver Deep Dive:**

The default bridge driver creates an isolated network on your host. Here's what happens when you create a bridge network:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 BRIDGE NETWORK CREATION                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  docker network create mynetwork                                 â”‚
â”‚                                                                  â”‚
â”‚  What Docker does:                                               â”‚
â”‚  1. Creates a Linux bridge interface (br-XXXX)                  â”‚
â”‚  2. Assigns subnet from Docker's pool (default: 172.18.0.0/16)  â”‚
â”‚  3. Configures iptables rules for NAT and forwarding            â”‚
â”‚  4. Starts embedded DNS server for this network                 â”‚
â”‚  5. Adds network metadata to Docker's database                  â”‚
â”‚                                                                  â”‚
â”‚  Default vs User-defined bridge:                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ Default (docker0)    â”‚ User-defined                     â”‚    â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”‚
â”‚  â”‚ No automatic DNS     â”‚ Built-in DNS by container name   â”‚    â”‚
â”‚  â”‚ --link required      â”‚ All containers can resolve each  â”‚    â”‚
â”‚  â”‚ Legacy approach      â”‚ Recommended approach             â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**How DNS Resolution Works (Service Discovery):**

Docker's embedded DNS server (`127.0.0.11`) provides automatic name resolution on user-defined networks:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DNS RESOLUTION FLOW                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  Container "web" wants to connect to container "db"             â”‚
â”‚                                                                  â”‚
â”‚  1. Application calls: connect("db", 5432)                      â”‚
â”‚                          â”‚                                       â”‚
â”‚  2. DNS lookup: db â†’ ?   â–¼                                       â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚     â”‚  Container's /etc/resolv.conf          â”‚                  â”‚
â”‚     â”‚  nameserver 127.0.0.11                 â”‚                  â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚                         â”‚                                        â”‚
â”‚  3. Query to Docker DNS â–¼                                        â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚     â”‚  Docker Embedded DNS Server            â”‚                  â”‚
â”‚     â”‚  (running in dockerd process)          â”‚                  â”‚
â”‚     â”‚                                        â”‚                  â”‚
â”‚     â”‚  Checks: Is "db" a container name      â”‚                  â”‚
â”‚     â”‚          on this network?              â”‚                  â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚                         â”‚                                        â”‚
â”‚  4. Response: db â†’ 172.18.0.3                                    â”‚
â”‚                         â”‚                                        â”‚
â”‚  5. TCP connection to 172.18.0.3:5432                            â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Port Mapping and iptables:**

When you publish a port (`-p 8080:80`), Docker configures iptables NAT rules:

```bash
# Docker adds these iptables rules:

# 1. DNAT rule - redirect incoming traffic to container
iptables -t nat -A DOCKER -p tcp --dport 8080 \
  -j DNAT --to-destination 172.17.0.2:80

# 2. FORWARD rule - allow traffic to reach container
iptables -A DOCKER -d 172.17.0.2 -p tcp --dport 80 -j ACCEPT

# View Docker's iptables rules
sudo iptables -t nat -L -n
sudo iptables -L DOCKER -n
```

### How Container-to-Container Communication Works

**On the Same Network:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    BRIDGE NETWORK                                â”‚
â”‚                                                                  â”‚
â”‚    Container A                        Container B               â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚    â”‚  eth0        â”‚                  â”‚  eth0        â”‚          â”‚
â”‚    â”‚  172.17.0.2  â”‚                  â”‚  172.17.0.3  â”‚          â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚           â”‚ veth                            â”‚ veth              â”‚
â”‚           â”‚                                 â”‚                   â”‚
â”‚    â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•â•       â”‚
â”‚                     Docker Bridge (docker0)                     â”‚
â”‚                        172.17.0.1                               â”‚
â”‚    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•     â”‚
â”‚                              â”‚                                   â”‚
â”‚                         NAT/iptables                            â”‚
â”‚                              â”‚                                   â”‚
â”‚    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•     â”‚
â”‚                     Host Network Interface                      â”‚
â”‚                              â”‚                                   â”‚
â”‚                          Internet                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**DNS Resolution:**
Containers on user-defined networks can resolve each other by **container name** or **network alias**. This is called **service discovery**.

```bash
# Container "web" can reach container "db" by name
docker exec web ping db  # Works because of built-in DNS
```

### Port Mapping Deep Dive

Port mapping allows external access to container services:

```
Host Port       â†’ Container Port
-p 8080:80      â†’ Request to host:8080 forwarded to container:80
-p 127.0.0.1:8080:80  â†’ Only localhost can access
-p 8080-8090:80-90    â†’ Port range mapping
-P                     â†’ Publish all EXPOSE ports to random host ports
```

**How It Works Internally:**

1. Docker creates iptables rules to forward traffic
2. Traffic to host port is DNATed to container's IP:port
3. Response traffic is SNATed back to the client

### Network Types

```bash
# List networks
docker network ls

# Network types:
# - bridge:  Default network, containers can communicate
# - host:    Use host's network directly
# - none:    No networking
# - overlay: Multi-host networking (Swarm)
# - macvlan: Assign MAC address to container

# Create network
docker network create mynetwork
docker network create --driver bridge mybridge
docker network create --subnet=172.20.0.0/16 mynetwork

# Inspect network
docker network inspect bridge

# Connect/disconnect containers
docker network connect mynetwork container_name
docker network disconnect mynetwork container_name

# Run with network
docker run -d --network mynetwork --name app nginx
docker run -d --network host nginx
docker run -d --network none nginx

# Remove network
docker network rm mynetwork
docker network prune        # Remove unused networks
```

### Container Communication

```bash
# Containers on same custom network can communicate by name
docker network create app-network

docker run -d --name db --network app-network postgres
docker run -d --name api --network app-network \
  -e DATABASE_HOST=db \      # Use container name
  myapi

# Link (legacy, use networks instead)
docker run -d --name db postgres
docker run -d --link db:database myapp

# Port publishing
docker run -d -p 8080:80 nginx                    # Specific port
docker run -d -p 80 nginx                         # Random host port
docker run -d -p 127.0.0.1:8080:80 nginx          # Bind to localhost only
docker run -d -p 8080-8090:80-90 nginx            # Port range
docker run -d -P nginx                            # Publish all exposed ports
```

### DNS and Service Discovery

```bash
# Built-in DNS for custom networks
# Containers can resolve each other by name

# Example
docker network create mynet
docker run -d --name web --network mynet nginx
docker run -it --network mynet alpine ping web   # Works!

# Custom DNS
docker run --dns 8.8.8.8 nginx
docker run --dns-search example.com nginx

# Add host entry
docker run --add-host host.docker.internal:host-gateway nginx
```

---

## 5. Storage & Volumes

### The Data Persistence Challenge

By default, all files created inside a container are stored in a **writable container layer**. This creates several problems:

**Why Container Storage is Problematic:**

| Problem | Explanation |
|---------|-------------|
| **Data Loss** | When a container is removed, its writable layer is deleted. All data is gone forever. |
| **Not Shareable** | Data in one container cannot easily be accessed by another container. |
| **Coupled to Host** | The container's storage driver is tied to the host machine. |
| **Performance** | Union filesystems add overhead compared to direct filesystem access. |

**Understanding Where Container Data Lives:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 DOCKER STORAGE ARCHITECTURE                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚    /var/lib/docker/                                             â”‚
â”‚    â”œâ”€â”€ overlay2/           â† Image layers and container layers â”‚
â”‚    â”‚   â”œâ”€â”€ l/              â† Shortened layer IDs               â”‚
â”‚    â”‚   â”œâ”€â”€ <layer-id>/     â† Each layer's content              â”‚
â”‚    â”‚   â””â”€â”€ <container-id>/ â† Container's writable layer        â”‚
â”‚    â”‚       â”œâ”€â”€ diff/       â† Changes made by container         â”‚
â”‚    â”‚       â”œâ”€â”€ merged/     â† Union view (what container sees)  â”‚
â”‚    â”‚       â””â”€â”€ work/       â† OverlayFS working directory       â”‚
â”‚    â”‚                                                            â”‚
â”‚    â”œâ”€â”€ volumes/            â† Named volumes                      â”‚
â”‚    â”‚   â”œâ”€â”€ mydata/                                              â”‚
â”‚    â”‚   â”‚   â””â”€â”€ _data/      â† Actual volume data                â”‚
â”‚    â”‚   â””â”€â”€ metadata.db     â† Volume metadata                   â”‚
â”‚    â”‚                                                            â”‚
â”‚    â”œâ”€â”€ containers/         â† Container configs and logs        â”‚
â”‚    â”‚   â””â”€â”€ <container-id>/                                      â”‚
â”‚    â”‚       â”œâ”€â”€ config.v2.json                                   â”‚
â”‚    â”‚       â””â”€â”€ <container-id>-json.log                          â”‚
â”‚    â”‚                                                            â”‚
â”‚    â””â”€â”€ image/              â† Image metadata                      â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Storage Drivers Explained:**

Docker uses **storage drivers** to manage the layered filesystem. The choice of driver affects performance and compatibility:

| Driver | Filesystem | Best For | Performance |
|--------|------------|----------|-------------|
| **overlay2** | xfs, ext4 | Default for modern Linux | Excellent |
| **fuse-overlayfs** | Any | Rootless Docker | Good |
| **btrfs** | btrfs | Btrfs filesystems | Good, native CoW |
| **zfs** | zfs | ZFS filesystems | Good, native CoW |
| **vfs** | Any | Testing only | Poor (no CoW) |

**How OverlayFS Works (Deep Dive):**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   OVERLAYFS INTERNALS                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚    What the container sees (merged view):                        â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚    â”‚  /                                                       â”‚ â”‚
â”‚    â”‚  â”œâ”€â”€ bin/bash (from layer 1)                            â”‚ â”‚
â”‚    â”‚  â”œâ”€â”€ etc/nginx/nginx.conf (from layer 3, modified)      â”‚ â”‚
â”‚    â”‚  â”œâ”€â”€ var/log/app.log (from container layer, new file)   â”‚ â”‚
â”‚    â”‚  â””â”€â”€ usr/share/nginx/ (from layer 2)                    â”‚ â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â–²                                   â”‚
â”‚                              â”‚ OverlayFS merges                  â”‚
â”‚                              â”‚                                   â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚    â”‚ Upper (RW)    â”‚  â”‚               â”‚  â”‚               â”‚     â”‚
â”‚    â”‚ container     â”‚  â”‚   Lower 3     â”‚  â”‚   Lower 2     â”‚     â”‚
â”‚    â”‚ layer         â”‚  â”‚   (COPY)      â”‚  â”‚   (RUN)       â”‚     â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚           â–²                  â–²                  â–²                â”‚
â”‚           â”‚                  â”‚                  â”‚                â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚    â”‚                    Lower 1 (FROM)                  â”‚        â”‚
â”‚    â”‚                    Base image layer                â”‚        â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                THE DATA PERSISTENCE PROBLEM                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  WITHOUT VOLUMES:                                                â”‚
â”‚                                                                  â”‚
â”‚    Container A                      Container A (new)           â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    docker rm    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚    â”‚ App Data    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶  â”‚ Empty!      â”‚              â”‚
â”‚    â”‚ DB Files    â”‚    + run        â”‚ No data!    â”‚              â”‚
â”‚    â”‚ Uploads     â”‚                 â”‚             â”‚              â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚         âŒ All data lost!                                        â”‚
â”‚                                                                  â”‚
â”‚  WITH VOLUMES:                                                   â”‚
â”‚                                                                  â”‚
â”‚    Container A                      Container B (new)           â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    docker rm    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚    â”‚ App         â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶  â”‚ App         â”‚              â”‚
â”‚    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    + run        â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚          â”‚ mount                         â”‚ mount                 â”‚
â”‚          â–¼                               â–¼                       â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚    â”‚            VOLUME (persistent)               â”‚              â”‚
â”‚    â”‚  DB Files, Uploads, Config files            â”‚              â”‚
â”‚    â”‚           (survives container removal)      â”‚              â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚         âœ… Data persists!                                        â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Storage Options Compared

Docker provides three ways to store data:

| Type | Location | Managed By | Persistence | Use Case |
|------|----------|------------|-------------|----------|
| **Volumes** | `/var/lib/docker/volumes/` | Docker | Yes | Production data, databases |
| **Bind Mounts** | Anywhere on host | You | Yes | Development, config files |
| **tmpfs** | Host memory (RAM) | Docker | No (until restart) | Secrets, temporary cache |

**When to Use Each:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                CHOOSING STORAGE TYPE                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  VOLUMES (Recommended for most cases)                           â”‚
â”‚  âœ… Best for: Databases, application data, shared data          â”‚
â”‚  âœ… Docker manages them (easy backup, migration)                â”‚
â”‚  âœ… Work on Linux and Windows containers                        â”‚
â”‚  âœ… Can be shared among multiple containers                     â”‚
â”‚  âœ… Volume drivers allow remote/cloud storage                   â”‚
â”‚                                                                  â”‚
â”‚  BIND MOUNTS                                                     â”‚
â”‚  âœ… Best for: Dev environments, config files, source code       â”‚
â”‚  âš ï¸  Depends on host filesystem structure                       â”‚
â”‚  âš ï¸  Security risk (container can access host files)            â”‚
â”‚  âœ… Changes reflect immediately (great for development)         â”‚
â”‚                                                                  â”‚
â”‚  TMPFS                                                           â”‚
â”‚  âœ… Best for: Secrets, sensitive data, temporary cache          â”‚
â”‚  âœ… Never written to disk (security)                            â”‚
â”‚  âŒ Lost when container stops                                    â”‚
â”‚  âŒ Cannot be shared between containers                         â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Volume Types

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Storage Options                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  1. Volumes (Managed by Docker)                                  â”‚
â”‚     docker volume create mydata                                  â”‚
â”‚     docker run -v mydata:/data nginx                            â”‚
â”‚                                                                  â”‚
â”‚  2. Bind Mounts (Host path)                                      â”‚
â”‚     docker run -v /host/path:/container/path nginx              â”‚
â”‚                                                                  â”‚
â”‚  3. tmpfs (Memory)                                               â”‚
â”‚     docker run --tmpfs /app/temp nginx                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Volume Management

```bash
# Create volume
docker volume create mydata
docker volume create --driver local mydata

# List volumes
docker volume ls

# Inspect volume
docker volume inspect mydata

# Remove volumes
docker volume rm mydata
docker volume prune                   # Remove unused volumes

# Use volume
docker run -v mydata:/data nginx
docker run --mount source=mydata,target=/data nginx

# Anonymous volume
docker run -v /data nginx             # Docker creates volume

# Read-only volume
docker run -v mydata:/data:ro nginx
```

### Bind Mounts

```bash
# Bind mount (absolute path)
docker run -v /host/path:/container/path nginx

# Bind mount (current directory)
docker run -v $(pwd):/app nginx

# Bind mount (read-only)
docker run -v /host/path:/container/path:ro nginx

# Using --mount (more explicit)
docker run --mount type=bind,source=/host/path,target=/container/path nginx

# Bind mount specific file
docker run -v /host/config.yaml:/app/config.yaml:ro nginx
```

### tmpfs Mounts

```bash
# tmpfs mount (memory only, not persisted)
docker run --tmpfs /app/temp nginx

docker run --mount type=tmpfs,destination=/app/temp,tmpfs-size=100m nginx
```

---

## 6. Docker Compose

### Understanding Docker Compose

Docker Compose is a tool for defining and running **multi-container Docker applications**. Instead of running each container separately with long `docker run` commands, you define your entire application stack in a single file.

**The Evolution of Container Orchestration:**

Docker Compose sits at an interesting point in the container orchestration spectrum:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              CONTAINER ORCHESTRATION SPECTRUM                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚    Simple                                            Complex     â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚    â”‚                                                        â”‚   â”‚
â”‚    â”‚  docker run  â”€â”€â–¶  Docker Compose  â”€â”€â–¶  Docker Swarm    â”‚   â”‚
â”‚    â”‚                                            â”‚           â”‚   â”‚
â”‚    â”‚  Single           Multi-container         Multi-host   â”‚   â”‚
â”‚    â”‚  container        single host             clusters     â”‚   â”‚
â”‚    â”‚                          â”‚                     â”‚       â”‚   â”‚
â”‚    â”‚                          â”‚                     â–¼       â”‚   â”‚
â”‚    â”‚                          â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚    â”‚                          â”‚              â”‚Kubernetesâ”‚   â”‚   â”‚
â”‚    â”‚                          â”‚              â”‚  (K8s)   â”‚   â”‚   â”‚
â”‚    â”‚                          â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚    â”‚                          â”‚              Production     â”‚   â”‚
â”‚    â”‚                          â”‚              at scale       â”‚   â”‚
â”‚    â”‚                          â”‚                             â”‚   â”‚
â”‚    â”‚                    â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”                       â”‚   â”‚
â”‚    â”‚                    â”‚ Sweet Spotâ”‚                       â”‚   â”‚
â”‚    â”‚                    â”‚ for most  â”‚                       â”‚   â”‚
â”‚    â”‚                    â”‚ dev teams â”‚                       â”‚   â”‚
â”‚    â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â”‚   â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Why Docker Compose?**

| Challenge Without Compose | Solution With Compose |
|---------------------------|----------------------|
| Long `docker run` commands with many flags | All configuration in one YAML file |
| Manual container start order | Automatic dependency management |
| Hard to share development environments | `docker-compose.yml` is version controlled |
| Manual network creation and linking | Networks created automatically |
| Inconsistent local vs team environments | Everyone uses same configuration |

**The Declarative Approach:**

Compose uses a **declarative model** â€“ you describe the desired end state, not the steps to get there:

| Imperative (Without Compose) | Declarative (With Compose) |
|------------------------------|---------------------------|
| "Create network. Start db. Wait. Start api. Configure env vars..." | "I want: web, api, db services on shared network" |
| You manage the sequence | Compose figures out the order |
| Easy to make mistakes | Configuration is consistent |
| Hard to reproduce | `docker-compose up` recreates everything |

**How Docker Compose Manages Lifecycle:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 COMPOSE LIFECYCLE MANAGEMENT                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  docker-compose up                                               â”‚
â”‚       â”‚                                                          â”‚
â”‚       â”œâ”€â–¶ 1. Read docker-compose.yml                            â”‚
â”‚       â”‚                                                          â”‚
â”‚       â”œâ”€â–¶ 2. Create project network (if not exists)             â”‚
â”‚       â”‚      myapp_default                                       â”‚
â”‚       â”‚                                                          â”‚
â”‚       â”œâ”€â–¶ 3. Create volumes (if not exists)                     â”‚
â”‚       â”‚      myapp_db_data                                       â”‚
â”‚       â”‚                                                          â”‚
â”‚       â”œâ”€â–¶ 4. Build images (if build: specified)                 â”‚
â”‚       â”‚      Check cache, rebuild if Dockerfile changed          â”‚
â”‚       â”‚                                                          â”‚
â”‚       â”œâ”€â–¶ 5. Create containers in dependency order              â”‚
â”‚       â”‚      db â†’ api â†’ web (based on depends_on)               â”‚
â”‚       â”‚                                                          â”‚
â”‚       â”œâ”€â–¶ 6. Start containers                                   â”‚
â”‚       â”‚      Attach to network, mount volumes                    â”‚
â”‚       â”‚                                                          â”‚
â”‚       â””â”€â–¶ 7. Stream logs (unless -d)                            â”‚
â”‚                                                                  â”‚
â”‚  docker-compose down                                             â”‚
â”‚       â”‚                                                          â”‚
â”‚       â”œâ”€â–¶ 1. Stop containers (SIGTERM, then SIGKILL)            â”‚
â”‚       â”œâ”€â–¶ 2. Remove containers                                  â”‚
â”‚       â”œâ”€â–¶ 3. Remove network                                     â”‚
â”‚       â””â”€â–¶ 4. Volumes preserved (unless -v flag)                 â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**How Docker Compose Works:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 DOCKER COMPOSE ARCHITECTURE                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   docker-compose.yml                                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚ version: '3.8'                                          â”‚   â”‚
â”‚   â”‚ services:                                               â”‚   â”‚
â”‚   â”‚   web:        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶  Container: myapp_web_1       â”‚   â”‚
â”‚   â”‚   api:        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶  Container: myapp_api_1       â”‚   â”‚
â”‚   â”‚   db:         â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶  Container: myapp_db_1        â”‚   â”‚
â”‚   â”‚   redis:      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶  Container: myapp_redis_1     â”‚   â”‚
â”‚   â”‚ networks:                                               â”‚   â”‚
â”‚   â”‚   frontend:   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶  Network: myapp_frontend      â”‚   â”‚
â”‚   â”‚   backend:    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶  Network: myapp_backend       â”‚   â”‚
â”‚   â”‚ volumes:                                                â”‚   â”‚
â”‚   â”‚   db_data:    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶  Volume: myapp_db_data        â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                  â”‚
â”‚   $ docker-compose up                                            â”‚
â”‚                       â”‚                                          â”‚
â”‚                       â–¼                                          â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚               RUNNING APPLICATION                        â”‚   â”‚
â”‚   â”‚                                                          â”‚   â”‚
â”‚   â”‚    â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”            â”‚   â”‚
â”‚   â”‚    â”‚ web â”‚â”€â”€â”€â–¶â”‚ api â”‚â”€â”€â”€â–¶â”‚ db  â”‚    â”‚redisâ”‚            â”‚   â”‚
â”‚   â”‚    â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜            â”‚   â”‚
â”‚   â”‚        â”‚                     â”‚                          â”‚   â”‚
â”‚   â”‚        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚   â”‚
â”‚   â”‚               shared volume                             â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Key Compose Concepts:**

| Concept | Description |
|---------|-------------|
| **Project** | A group of containers defined in one compose file. Named after directory by default. |
| **Service** | A container configuration that can be scaled to multiple instances. |
| **Network** | Virtual network for service communication. Created per project by default. |
| **Volume** | Persistent storage that survives container restarts. |
| **Profile** | Groups services that should only start in certain scenarios (e.g., debugging tools). |

**Compose vs Kubernetes:**

| Aspect | Docker Compose | Kubernetes |
|--------|----------------|------------|
| **Scope** | Single host | Multi-host cluster |
| **Complexity** | Simple, easy to learn | Complex, steep learning curve |
| **Scaling** | Manual or basic (`--scale`) | Auto-scaling, self-healing |
| **Use Case** | Development, simple deployments | Production, large-scale systems |
| **State** | Stateful by default | Prefers stateless, manages state specially |

### Compose File Reference

```yaml
# docker-compose.yml
version: '3.8'

services:
  # Frontend service
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      args:
        NODE_ENV: production
      target: production
    image: myapp/frontend:${TAG:-latest}
    container_name: frontend
    hostname: frontend
    ports:
      - "3000:3000"
      - "3001:3001"
    volumes:
      - ./frontend/src:/app/src:ro
      - frontend_node_modules:/app/node_modules
    environment:
      - NODE_ENV=production
      - API_URL=http://api:8000
    env_file:
      - .env
      - .env.production
    depends_on:
      api:
        condition: service_healthy
    networks:
      - frontend-network
      - backend-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 256M
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  # API service
  api:
    build:
      context: ./api
      dockerfile: Dockerfile.prod
    ports:
      - "8000:8000"
    volumes:
      - ./api:/app
      - /app/node_modules
    environment:
      DATABASE_URL: postgres://user:password@db:5432/myapp
      REDIS_URL: redis://cache:6379
      SECRET_KEY: ${SECRET_KEY}
    depends_on:
      db:
        condition: service_healthy
      cache:
        condition: service_started
    networks:
      - backend-network
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:8000/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  # Database service
  db:
    image: postgres:15-alpine
    container_name: postgres
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: myapp
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U user -d myapp"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - backend-network
    restart: unless-stopped

  # Cache service
  cache:
    image: redis:7-alpine
    command: redis-server --appendonly yes
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - backend-network
    restart: unless-stopped

  # Nginx reverse proxy
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
    depends_on:
      - frontend
      - api
    networks:
      - frontend-network
      - backend-network
    restart: unless-stopped

  # Worker service
  worker:
    build: ./worker
    command: celery -A tasks worker --loglevel=info
    volumes:
      - ./worker:/app
    environment:
      - REDIS_URL=redis://cache:6379
    depends_on:
      - cache
    networks:
      - backend-network
    restart: unless-stopped
    deploy:
      replicas: 2

# Volumes
volumes:
  postgres_data:
    driver: local
  redis_data:
  frontend_node_modules:

# Networks
networks:
  frontend-network:
    driver: bridge
  backend-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.28.0.0/16
```

### Compose Commands

```bash
# Start services
docker compose up
docker compose up -d                   # Detached mode
docker compose up --build              # Rebuild images
docker compose up service1 service2    # Specific services
docker compose up --scale worker=3     # Scale service

# Stop services
docker compose down
docker compose down -v                 # Remove volumes
docker compose down --rmi all          # Remove images
docker compose stop                    # Stop without removing

# View status
docker compose ps
docker compose ps -a
docker compose top

# Logs
docker compose logs
docker compose logs -f                 # Follow
docker compose logs service_name
docker compose logs --tail 100

# Execute commands
docker compose exec service_name command
docker compose exec db psql -U user -d myapp

# Build
docker compose build
docker compose build --no-cache
docker compose build service_name

# Other commands
docker compose pull                    # Pull latest images
docker compose restart                 # Restart services
docker compose config                  # Validate and view config
docker compose config --services       # List services
docker compose images                  # List images
docker compose port service 80         # Show port mapping
```

### Environment Files

```bash
# .env file (automatically loaded)
TAG=v1.0
SECRET_KEY=mysecretkey
DATABASE_PASSWORD=password

# Multiple env files
docker compose --env-file .env.production up

# In compose file
services:
  app:
    env_file:
      - .env
      - .env.local
```

---

## 7. Multi-Stage Builds

### Pattern: Build and Runtime Separation

```dockerfile
# Stage 1: Build
FROM node:18-alpine AS builder

WORKDIR /app

# Install dependencies
COPY package*.json ./
RUN npm ci

# Build application
COPY . .
RUN npm run build

# Stage 2: Runtime
FROM node:18-alpine AS runtime

WORKDIR /app

# Copy only production dependencies
COPY package*.json ./
RUN npm ci --only=production

# Copy built application from builder
COPY --from=builder /app/dist ./dist

# Non-root user
USER node

EXPOSE 3000
CMD ["node", "dist/server.js"]
```

### Pattern: Multi-Environment Builds

```dockerfile
# Base stage
FROM python:3.11-slim AS base
WORKDIR /app
COPY requirements.txt .

# Development stage
FROM base AS development
RUN pip install -r requirements.txt
RUN pip install pytest pytest-cov black flake8
COPY . .
CMD ["python", "-m", "flask", "run", "--host=0.0.0.0", "--debug"]

# Test stage
FROM development AS test
RUN pytest tests/

# Production stage
FROM base AS production
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
RUN useradd -r appuser && chown -R appuser /app
USER appuser
CMD ["gunicorn", "-b", "0.0.0.0:8000", "app:app"]
```

### Build Specific Targets

```bash
# Build development image
docker build --target development -t myapp:dev .

# Build production image
docker build --target production -t myapp:prod .

# Build test image and run tests
docker build --target test -t myapp:test .
```

---

## 8. Security Best Practices

### Dockerfile Security

```dockerfile
# 1. Use specific base image versions
FROM python:3.11.4-slim-bookworm    # Not python:latest

# 2. Create and use non-root user
RUN groupadd -r appgroup && useradd -r -g appgroup appuser
USER appuser

# 3. Use COPY instead of ADD (unless extracting tar)
COPY requirements.txt .              # Preferred
#ADD requirements.txt .              # Avoid

# 4. Don't store secrets in images
# Use secrets at runtime, not build time
# Bad: ENV API_KEY=secret
# Good: Pass at runtime with -e or secrets

# 5. Use multi-stage builds to exclude build tools
FROM node:18 AS builder
# ... build steps
FROM node:18-slim
COPY --from=builder /app/dist ./dist

# 6. Scan for vulnerabilities
# docker scan myimage

# 7. Set read-only filesystem where possible
# docker run --read-only myimage

# 8. Drop capabilities
# docker run --cap-drop=ALL --cap-add=NET_BIND_SERVICE myimage

# 9. Use .dockerignore
# Create .dockerignore file
```

### .dockerignore Example

```dockerignore
# Git
.git
.gitignore

# Docker
Dockerfile*
docker-compose*
.docker

# Dependencies
node_modules
vendor
__pycache__
*.pyc

# IDE
.idea
.vscode
*.swp
*.swo

# Testing
coverage
.pytest_cache
.nyc_output

# Environment
.env
.env.*
*.local

# Logs
*.log
logs

# Build artifacts
dist
build
*.tar.gz

# Documentation
docs
*.md
!README.md

# Secrets
*.pem
*.key
secrets
```

### Runtime Security

```bash
# Run as non-root
docker run --user 1000:1000 myimage

# Read-only filesystem
docker run --read-only myimage
docker run --read-only --tmpfs /tmp myimage

# Drop capabilities
docker run --cap-drop=ALL myimage
docker run --cap-drop=ALL --cap-add=CHOWN myimage

# Security options
docker run --security-opt=no-new-privileges myimage
docker run --security-opt apparmor=docker-default myimage

# Resource limits
docker run --memory="512m" --cpus="1.0" myimage
docker run --pids-limit=100 myimage

# Network restrictions
docker run --network=none myimage

# Read-only mounts
docker run -v /host/path:/container/path:ro myimage
```

### Image Scanning

```bash
# Docker Scout (built-in)
docker scout cves myimage
docker scout recommendations myimage

# Trivy
trivy image myimage

# Snyk
snyk container test myimage

# Anchore
anchore-cli image add myimage
anchore-cli image vuln myimage
```

---

## 9. Performance Optimization

### Build Optimization

```dockerfile
# 1. Order layers from least to most frequently changed
FROM python:3.11-slim
WORKDIR /app

# Rarely changes
COPY requirements.txt .
RUN pip install -r requirements.txt

# Changes often
COPY . .

# 2. Combine RUN commands to reduce layers
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
        package1 \
        package2 && \
    rm -rf /var/lib/apt/lists/*

# 3. Use .dockerignore to reduce context size

# 4. Use BuildKit
DOCKER_BUILDKIT=1 docker build .

# 5. Use cache mounts
RUN --mount=type=cache,target=/root/.cache/pip \
    pip install -r requirements.txt
```

### Runtime Optimization

```bash
# Resource limits
docker run \
  --memory="512m" \
  --memory-swap="1g" \
  --cpus="1.5" \
  --cpu-shares=512 \
  myimage

# Logging limits
docker run \
  --log-opt max-size=10m \
  --log-opt max-file=3 \
  myimage

# Storage driver
# Use overlay2 (default on modern Docker)

# Check image size
docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"

# Analyze layers
docker history myimage
dive myimage  # Third-party tool for layer analysis
```

### Image Size Optimization

```dockerfile
# Use slim/alpine base images
FROM python:3.11-slim      # Instead of python:3.11
FROM node:18-alpine        # Instead of node:18

# Remove package manager cache
RUN apt-get update && \
    apt-get install -y package && \
    rm -rf /var/lib/apt/lists/*

RUN apk add --no-cache package  # Alpine

# Don't install dev dependencies in production
RUN npm ci --only=production

# Use multi-stage builds
FROM builder AS final
COPY --from=builder /app/dist ./dist

# Remove unnecessary files
RUN rm -rf /tmp/* /var/tmp/*
```

---

## 10. Production Patterns

### Container Orchestration Readiness

```dockerfile
# Production-ready Dockerfile
FROM python:3.11-slim AS base

# Security: Create non-root user
RUN groupadd -r app && useradd -r -g app app

# Performance: Set environment
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1

WORKDIR /app

# Dependencies first (caching)
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Application
COPY --chown=app:app . .

USER app

EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

# Graceful shutdown
STOPSIGNAL SIGTERM

CMD ["gunicorn", "--bind", "0.0.0.0:8000", "--workers", "4", "app:app"]
```

### Entrypoint Scripts

```bash
#!/bin/bash
# docker-entrypoint.sh
set -e

# Wait for dependencies
wait_for_service() {
    host=$1
    port=$2
    echo "Waiting for $host:$port..."
    while ! nc -z "$host" "$port"; do
        sleep 1
    done
    echo "$host:$port is available"
}

# Wait for database
if [ -n "$DATABASE_HOST" ]; then
    wait_for_service "$DATABASE_HOST" "${DATABASE_PORT:-5432}"
fi

# Run migrations
if [ "$RUN_MIGRATIONS" = "true" ]; then
    echo "Running migrations..."
    python manage.py migrate
fi

# Execute main command
exec "$@"
```

```dockerfile
COPY docker-entrypoint.sh /
RUN chmod +x /docker-entrypoint.sh
ENTRYPOINT ["/docker-entrypoint.sh"]
CMD ["gunicorn", "app:app"]
```

### Logging Best Practices

```dockerfile
# Log to stdout/stderr (not files)
CMD ["app", "--log-format", "json", "--log-output", "stdout"]
```

```bash
# Docker logging drivers
docker run --log-driver json-file \
  --log-opt max-size=10m \
  --log-opt max-file=3 \
  myimage

# Other drivers: syslog, journald, fluentd, awslogs, gcplogs
```

### Quick Reference

```bash
# === CONTAINER LIFECYCLE ===
docker run -d --name app -p 8080:80 nginx
docker exec -it app bash
docker logs -f app
docker stop app && docker rm app

# === IMAGES ===
docker build -t myapp:v1 .
docker push registry/myapp:v1
docker pull registry/myapp:v1
docker images && docker rmi imageid

# === VOLUMES ===
docker volume create data
docker run -v data:/app/data myapp
docker run -v $(pwd):/app myapp

# === NETWORKS ===
docker network create mynet
docker run --network mynet myapp

# === COMPOSE ===
docker compose up -d
docker compose down -v
docker compose logs -f

# === CLEANUP ===
docker system prune -af --volumes
```

---

*This guide covers Docker comprehensively. Continue to the Kubernetes guide for container orchestration.*
